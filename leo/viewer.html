<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>View Scrubbai - Markdown Viewer & Editor</title>

    <!-- Bootswatch Theme CSS (Flatly for light, Darkly for dark) -->
    <link id="theme-stylesheet" href="https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/flatly/bootstrap.min.css" rel="stylesheet">

    <!-- markdown-it Library (replacing marked.js for better source map support) -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"></script>

    <!-- Mermaid.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>

    <style>
        /* Light theme (Flatly) custom properties */
        :root {
            --viewer-bg: #ecf0f1;
            --viewer-card-bg: #ffffff;
            --viewer-text: #2c3e50;
            --viewer-text-muted: #7b8a8b;
            --viewer-border: #dce4ec;
            --viewer-primary: #2c3e50;
            --viewer-accent: #18bc9c;
            --viewer-code-bg: #ecf0f1;
            --viewer-pre-bg: #2c3e50;
            --viewer-pre-text: #ecf0f1;
            --viewer-link: #18bc9c;
            --viewer-table-header: #2c3e50;
            --viewer-table-stripe: #f8f9fa;
            --viewer-shadow: rgba(0, 0, 0, 0.08);
            --viewer-divider-bg: #bdc3c7;
            --viewer-divider-hover: #95a5a6;
        }

        /* Dark theme (Darkly) custom properties */
        [data-theme="dark"] {
            --viewer-bg: #222222;
            --viewer-card-bg: #303030;
            --viewer-text: #ffffff;
            --viewer-text-muted: #adb5bd;
            --viewer-border: #444444;
            --viewer-primary: #00bc8c;
            --viewer-accent: #00bc8c;
            --viewer-code-bg: #444444;
            --viewer-pre-bg: #1a1a1a;
            --viewer-pre-text: #ffffff;
            --viewer-link: #00bc8c;
            --viewer-table-header: #00bc8c;
            --viewer-table-stripe: #3a3a3a;
            --viewer-shadow: rgba(0, 0, 0, 0.3);
            --viewer-divider-bg: #555555;
            --viewer-divider-hover: #00bc8c;
        }

        body {
            background-color: var(--viewer-bg);
            color: var(--viewer-text);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .header {
            background: var(--viewer-card-bg);
            color: var(--viewer-primary);
            padding: 1.5rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px var(--viewer-shadow);
            border-bottom: 3px solid var(--viewer-accent);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .header h1 {
            font-weight: 600;
            margin: 0;
            font-size: 2rem;
            color: var(--viewer-primary);
        }

        .header p {
            margin: 0.5rem 0 0 0;
            color: var(--viewer-text-muted);
            font-size: 0.95rem;
        }

        .editor-container {
            background: var(--viewer-card-bg);
            border-radius: 8px;
            padding: 2rem;
            box-shadow: 0 2px 8px var(--viewer-shadow);
            margin-bottom: 2rem;
            transition: background-color 0.3s ease;
        }

        .textarea-wrapper {
            position: relative;
            margin-bottom: 1.5rem;
        }

        #markdownInput {
            width: 100%;
            min-height: 400px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border: 2px solid var(--viewer-border);
            border-radius: 6px;
            padding: 1rem;
            resize: vertical;
            transition: border-color 0.3s ease, background-color 0.3s ease, color 0.3s ease;
            background-color: var(--viewer-card-bg);
            color: var(--viewer-text);
        }

        #markdownInput:focus {
            outline: none;
            border-color: var(--viewer-accent);
            box-shadow: 0 0 0 0.2rem rgba(24, 188, 156, 0.25);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 1.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .status-indicator::before {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.75rem;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-valid {
            background-color: rgba(0, 188, 140, 0.15);
            color: #00bc8c;
            border: 1px solid rgba(0, 188, 140, 0.4);
        }

        .status-valid::before {
            background-color: #00bc8c;
        }

        .status-warning {
            background-color: rgba(243, 156, 18, 0.15);
            color: #f39c12;
            border: 1px solid rgba(243, 156, 18, 0.4);
        }

        .status-warning::before {
            background-color: #f39c12;
        }

        .status-error {
            background-color: rgba(231, 76, 60, 0.15);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.4);
        }

        .status-error::before {
            background-color: #e74c3c;
        }

        .button-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .preview-container {
            background: var(--viewer-card-bg);
            border-radius: 8px;
            padding: 2rem;
            box-shadow: 0 2px 8px var(--viewer-shadow);
            min-height: 300px;
            transition: background-color 0.3s ease;
        }

        .preview-header {
            color: var(--viewer-primary);
            font-weight: 600;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--viewer-accent);
        }

        #markdownPreview {
            line-height: 1.6;
            color: var(--viewer-text);
        }

        /* Styled Markdown Output */
        #markdownPreview h1,
        #markdownPreview h2,
        #markdownPreview h3,
        #markdownPreview h4,
        #markdownPreview h5,
        #markdownPreview h6 {
            color: var(--viewer-primary);
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        #markdownPreview h1 {
            font-size: 2rem;
            border-bottom: 3px solid var(--viewer-accent);
            padding-bottom: 0.5rem;
        }

        #markdownPreview h2 {
            font-size: 1.75rem;
            border-bottom: 2px solid var(--viewer-border);
            padding-bottom: 0.4rem;
        }

        #markdownPreview h3 {
            font-size: 1.5rem;
        }

        #markdownPreview p {
            margin-bottom: 1rem;
        }

        #markdownPreview code {
            background-color: var(--viewer-code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--viewer-accent);
        }

        #markdownPreview pre {
            background-color: var(--viewer-pre-bg);
            color: var(--viewer-pre-text);
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        #markdownPreview pre code {
            background-color: transparent;
            color: var(--viewer-pre-text);
            padding: 0;
        }

        #markdownPreview blockquote {
            border-left: 4px solid var(--viewer-accent);
            padding-left: 1rem;
            margin-left: 0;
            color: var(--viewer-text-muted);
        }

        #markdownPreview a {
            color: var(--viewer-link);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.3s ease;
        }

        #markdownPreview a:hover {
            border-bottom-color: var(--viewer-link);
        }

        #markdownPreview ul,
        #markdownPreview ol {
            margin-bottom: 1rem;
            padding-left: 2rem;
        }

        #markdownPreview li {
            margin-bottom: 0.5rem;
        }

        #markdownPreview table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        #markdownPreview th,
        #markdownPreview td {
            border: 1px solid var(--viewer-border);
            padding: 0.75rem;
            text-align: left;
        }

        #markdownPreview th {
            background-color: var(--viewer-table-header);
            color: white;
            font-weight: 600;
        }

        #markdownPreview tr:nth-child(even) {
            background-color: var(--viewer-table-stripe);
        }

        #markdownPreview img {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            margin: 1rem 0;
        }

        #markdownPreview hr {
            border: 0;
            height: 2px;
            background: var(--viewer-accent);
            margin: 2rem 0;
        }

        .empty-state {
            text-align: left;
            color: var(--viewer-text-muted);
            padding: 3rem 0;
        }

        footer {
            text-align: left;
            padding: 2rem 0;
            color: var(--viewer-text-muted);
            font-size: 0.9rem;
        }

        /* Form label styling */
        .form-label {
            color: var(--viewer-primary);
        }

        /* Theme toggle styling */
        .theme-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .theme-toggle .form-check-input {
            width: 3rem;
            height: 1.5rem;
        }

        .theme-icon {
            font-size: 1.2rem;
        }

        /* Side-by-Side Layout Styles */
        .mode-side-by-side .view-mode-container {
            display: flex;
            align-items: stretch;
            height: calc(100vh - 180px);
            min-height: 500px;
            gap: 0;
        }

        .mode-side-by-side .editor-container {
            flex: 0 0 50%;
            margin-bottom: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-radius: 8px 0 0 8px;
        }

        .mode-side-by-side .preview-container {
            flex: 1;
            margin-bottom: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-radius: 0 8px 8px 0;
        }

        /* Resizable Divider */
        .resize-divider {
            display: none;
            width: 8px;
            background-color: var(--viewer-divider-bg);
            cursor: col-resize;
            flex-shrink: 0;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .resize-divider:hover,
        .resize-divider.dragging {
            background-color: var(--viewer-divider-hover);
        }

        .resize-divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 40px;
            background: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 3px,
                var(--viewer-card-bg) 3px,
                var(--viewer-card-bg) 6px
            );
            border-radius: 2px;
        }

        .mode-side-by-side .resize-divider {
            display: block;
        }

        .mode-side-by-side .textarea-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
        }

        .mode-side-by-side #markdownInput {
            flex: 1;
            resize: none;
            height: 100% !important;
            min-height: 0;
        }

        .mode-side-by-side #markdownPreview {
            overflow-y: auto;
            flex: 1;
            padding-right: 0.5rem;
        }

        /* Custom Scrollbar for side-by-side panels */
        .mode-side-by-side #markdownInput::-webkit-scrollbar,
        .mode-side-by-side #markdownPreview::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .mode-side-by-side #markdownInput::-webkit-scrollbar-track,
        .mode-side-by-side #markdownPreview::-webkit-scrollbar-track {
            background: var(--viewer-bg);
            border-radius: 4px;
        }

        .mode-side-by-side #markdownInput::-webkit-scrollbar-thumb,
        .mode-side-by-side #markdownPreview::-webkit-scrollbar-thumb {
            background: var(--viewer-divider-bg);
            border-radius: 4px;
        }

        .mode-side-by-side #markdownInput::-webkit-scrollbar-thumb:hover,
        .mode-side-by-side #markdownPreview::-webkit-scrollbar-thumb:hover {
            background: var(--viewer-divider-hover);
        }

        /* Hide elements that might clutter side-by-side view if needed */
        .mode-side-by-side .header {
            margin-bottom: 1rem;
        }

        /* Prevent text selection while dragging divider */
        body.resizing {
            user-select: none;
            cursor: col-resize;
        }

        /* Resizable Mermaid Diagram Container */
        .mermaid-container {
            position: relative;
            display: inline-block;
            min-width: 200px;
            max-width: 100%;
            margin: 1rem 0;
            border: 2px solid var(--viewer-border);
            border-radius: 6px;
            background-color: var(--viewer-card-bg);
            overflow: hidden;
        }

        .mermaid-container .mermaid {
            padding: 1rem;
            overflow: auto;
        }

        .mermaid-container .mermaid svg {
            max-width: 100%;
            height: auto;
            display: block;
        }

        .mermaid-resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 12px;
            background-color: var(--viewer-divider-bg);
            cursor: ew-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .mermaid-resize-handle:hover,
        .mermaid-resize-handle.dragging {
            background-color: var(--viewer-accent);
        }

        .mermaid-resize-handle::before {
            content: '';
            width: 4px;
            height: 30px;
            background: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 3px,
                var(--viewer-card-bg) 3px,
                var(--viewer-card-bg) 6px
            );
            border-radius: 2px;
        }

        .mermaid-width-indicator {
            position: absolute;
            top: 4px;
            left: 4px;
            background-color: var(--viewer-primary);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
            opacity: 0.8;
            pointer-events: none;
            z-index: 10;
        }

        .mermaid-container:hover .mermaid-width-indicator {
            opacity: 1;
        }

        /* Prevent text selection while resizing mermaid */
        body.resizing-mermaid {
            user-select: none;
            cursor: ew-resize;
        }

        /* Responsive override: Disable side-by-side on small screens */
        @media (max-width: 767.98px) {
            .mode-side-by-side .view-mode-container {
                display: block;
                height: auto;
            }
            .mode-side-by-side .editor-container,
            .mode-side-by-side .preview-container {
                width: 100% !important;
                flex: none;
                overflow: visible;
                height: auto;
                border-radius: 8px;
            }
            .mode-side-by-side .editor-container {
                margin-bottom: 2rem;
            }
            .mode-side-by-side #markdownInput {
                height: auto !important;
                resize: vertical;
            }
            .mode-side-by-side #markdownPreview {
                overflow-y: visible;
            }
            .mode-side-by-side .resize-divider {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="container d-flex justify-content-between align-items-center flex-wrap">
            <div>
                <h1>View Scrubbai</h1>
                <p>Professional Markdown Viewer & Editor</p>
            </div>
            <div class="settings-panel d-flex align-items-center gap-4 mt-3 mt-md-0">
                <div class="form-check form-switch d-none d-md-block">
                    <input class="form-check-input" type="checkbox" id="layoutToggle">
                    <label class="form-check-label" for="layoutToggle">Side-by-Side</label>
                </div>
                <div class="theme-toggle">
                    <span class="theme-icon" id="sunIcon">&#9728;</span>
                    <div class="form-check form-switch mb-0">
                        <input class="form-check-input" type="checkbox" id="themeToggle">
                    </div>
                    <span class="theme-icon" id="moonIcon">&#9790;</span>
                </div>
            </div>
        </div>
    </div>

    <div id="mainContainer" class="container">
        <div class="view-mode-container">
            <div class="editor-container">
                <div class="textarea-wrapper">
                    <label for="markdownInput" class="form-label fw-bold">
                        Markdown Editor
                    </label>
                    <textarea
                        id="markdownInput"
                        class="form-control"
                        rows="20"
                        placeholder="Type or paste your markdown here...&#10;&#10;# Example Heading&#10;&#10;This is a **bold** statement with *italic* text.&#10;&#10;- List item 1&#10;- List item 2&#10;&#10;```javascript&#10;console.log('Hello, World!');&#10;```&#10;&#10;```mermaid&#10;graph TD;&#10;    A-->B;&#10;```"
                    ></textarea>
                </div>

                <div id="statusIndicator" class="status-indicator status-valid">
                    Valid markdown - No issues detected
                </div>

                <div class="button-group">
                    <button id="clearBtn" class="btn btn-outline-secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16" style="margin-right: 0.5rem; vertical-align: text-bottom;">
                            <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                            <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/>
                        </svg>
                        Clear
                    </button>
                    <button id="rerenderBtn" class="btn btn-primary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-clockwise" viewBox="0 0 16 16" style="margin-right: 0.5rem; vertical-align: text-bottom;">
                            <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
                            <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
                        </svg>
                        Re-render
                    </button>
                </div>
            </div>

            <div class="resize-divider" id="resizeDivider"></div>

            <div class="preview-container">
                <h2 class="preview-header fw-bold" style="font-size: 1rem; margin-bottom: 0.5rem; border-bottom: none; padding-bottom: 0;">
                    Preview
                </h2>
                <div id="markdownPreview" class="empty-state">
                    Your rendered markdown will appear here...
                </div>
            </div>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>&copy; 2024 View Scrubbai. Built with markdown-it and Bootstrap 5.</p>
        </div>
    </footer>

    <!-- Bootstrap 5 JS Bundle (optional for this use case, but included for completeness) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

    <script>
        // =====================================================
        // MARKDOWN-IT CONFIGURATION WITH SOURCE LINE INJECTION
        // =====================================================

        // Initialize markdown-it with GFM-like options
        const md = window.markdownit({
            html: true,
            breaks: true,
            linkify: true,
            typographer: false
        });

        // Store the default fence renderer
        const defaultFenceRenderer = md.renderer.rules.fence || function(tokens, idx, options, env, self) {
            return self.renderToken(tokens, idx, options);
        };

        // Default Mermaid width
        const DEFAULT_MERMAID_WIDTH = 600;

        // Custom fence renderer for Mermaid support with resizable container
        md.renderer.rules.fence = function(tokens, idx, options, env, self) {
            const token = tokens[idx];
            const info = token.info ? token.info.trim() : '';
            const parts = info.split(/\s+/g);
            const lang = parts[0];

            if (lang === 'mermaid') {
                const line = token.map ? token.map[0] : 0;

                // Parse optional width from info string: ```mermaid width=500
                let width = DEFAULT_MERMAID_WIDTH;
                for (let i = 1; i < parts.length; i++) {
                    const match = parts[i].match(/^width=(\d+)$/);
                    if (match) {
                        width = parseInt(match[1], 10);
                    }
                }

                // Wrap in resizable container
                return `<div class="mermaid-container" data-source-line="${line}" style="width: ${width}px;">
                    <span class="mermaid-width-indicator">${width}px</span>
                    <div class="mermaid">${md.utils.escapeHtml(token.content)}</div>
                    <div class="mermaid-resize-handle" title="Drag to resize"></div>
                </div>`;
            }

            // For other code blocks, add source line and use default rendering
            const line = token.map ? token.map[0] : 0;
            const langClass = lang ? ` class="language-${lang}"` : '';
            const escaped = md.utils.escapeHtml(token.content);
            return `<pre data-source-line="${line}"><code${langClass}>${escaped}</code></pre>`;
        };

        // Inject source line numbers into block-level elements (VS Code approach)
        // This adds data-source-line attributes to rendered HTML for scroll sync
        md.core.ruler.push('source_line_injector', function(state) {
            for (let i = 0; i < state.tokens.length; i++) {
                const token = state.tokens[i];
                // Add line info to block tokens that have map info
                if (token.map && token.nesting >= 0) {
                    token.attrSet('data-source-line', String(token.map[0]));
                    token.attrJoin('class', 'source-line');
                }
            }
        });

        // Initialize Mermaid with sensible defaults
        mermaid.initialize({
            startOnLoad: false,
            flowchart: { useMaxWidth: true, htmlLabels: true },
            sequence: { useMaxWidth: true },
            gantt: { useMaxWidth: true },
            journey: { useMaxWidth: true },
            class: { useMaxWidth: true },
            state: { useMaxWidth: true },
            er: { useMaxWidth: true },
            pie: { useMaxWidth: true }
        });

        // =====================================================
        // DOM ELEMENTS
        // =====================================================

        const markdownInput = document.getElementById('markdownInput');
        const markdownPreview = document.getElementById('markdownPreview');
        const statusIndicator = document.getElementById('statusIndicator');
        const clearBtn = document.getElementById('clearBtn');
        const rerenderBtn = document.getElementById('rerenderBtn');

        const layoutToggle = document.getElementById('layoutToggle');
        const mainContainer = document.getElementById('mainContainer');
        const themeToggle = document.getElementById('themeToggle');
        const themeStylesheet = document.getElementById('theme-stylesheet');
        const resizeDivider = document.getElementById('resizeDivider');
        const editorContainer = document.querySelector('.editor-container');
        const previewContainer = document.querySelector('.preview-container');

        // Theme URLs
        const THEME_LIGHT = 'https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/flatly/bootstrap.min.css';
        const THEME_DARK = 'https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/darkly/bootstrap.min.css';

        // Debounce timer
        let debounceTimer;

        // =====================================================
        // SCROLL SYNC WITH SOURCE LINE MAPPING & INTERPOLATION
        // (Based on Joplin's SyncScrollMap approach)
        // =====================================================

        /**
         * SyncScrollMap - Manages mapping between editor lines and preview positions
         * Uses percentage-based positions for GUI-independence
         * Implements binary search for efficient lookups
         */
        class SyncScrollMap {
            constructor() {
                this.map = null; // Array of {line, percent} sorted by line
                this.valid = false;
            }

            /**
             * Build the mapping from source lines to preview scroll percentages
             */
            build() {
                const elements = markdownPreview.querySelectorAll('[data-source-line]');
                const previewScrollHeight = markdownPreview.scrollHeight - markdownPreview.clientHeight;

                if (previewScrollHeight <= 0 || elements.length === 0) {
                    this.map = [];
                    this.valid = true;
                    return;
                }

                const entries = [];
                const previewRect = markdownPreview.getBoundingClientRect();

                elements.forEach(el => {
                    const line = parseInt(el.getAttribute('data-source-line'), 10);
                    if (isNaN(line)) return;

                    const rect = el.getBoundingClientRect();
                    // Position relative to preview container
                    const top = rect.top - previewRect.top + markdownPreview.scrollTop;
                    // Convert to percentage (0 to 1)
                    const percent = Math.max(0, Math.min(1, top / previewScrollHeight));

                    entries.push({ line, percent });
                });

                // Sort by line number and remove duplicates (keep first occurrence)
                entries.sort((a, b) => a.line - b.line);
                this.map = [];
                let lastLine = -1;
                for (const entry of entries) {
                    if (entry.line !== lastLine) {
                        this.map.push(entry);
                        lastLine = entry.line;
                    }
                }

                this.valid = true;
            }

            /**
             * Invalidate the map (will be rebuilt on next use)
             */
            invalidate() {
                this.valid = false;
                this.map = null;
            }

            /**
             * Binary search to find the rightmost index where map[i].line <= targetLine
             * Returns -1 if all lines are greater than target
             */
            binarySearchByLine(targetLine) {
                if (!this.map || this.map.length === 0) return -1;

                let left = 0;
                let right = this.map.length - 1;
                let result = -1;

                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    if (this.map[mid].line <= targetLine) {
                        result = mid;
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }

                return result;
            }

            /**
             * Binary search to find the rightmost index where map[i].percent <= targetPercent
             */
            binarySearchByPercent(targetPercent) {
                if (!this.map || this.map.length === 0) return -1;

                let left = 0;
                let right = this.map.length - 1;
                let result = -1;

                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    if (this.map[mid].percent <= targetPercent) {
                        result = mid;
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }

                return result;
            }

            /**
             * Translate editor line to preview scroll percentage using linear interpolation
             */
            lineToPreviewPercent(line) {
                if (!this.valid) this.build();
                if (!this.map || this.map.length === 0) return null;

                // Edge cases
                if (line <= this.map[0].line) return this.map[0].percent;
                if (line >= this.map[this.map.length - 1].line) return this.map[this.map.length - 1].percent;

                // Binary search for the bracket
                const lowerIdx = this.binarySearchByLine(line);
                if (lowerIdx < 0) return this.map[0].percent;

                const upperIdx = lowerIdx + 1;
                if (upperIdx >= this.map.length) return this.map[lowerIdx].percent;

                const lower = this.map[lowerIdx];
                const upper = this.map[upperIdx];

                // Exact match
                if (lower.line === line) return lower.percent;

                // Linear interpolation
                const lineRange = upper.line - lower.line;
                if (lineRange === 0) return lower.percent;

                const ratio = (line - lower.line) / lineRange;
                return lower.percent + ratio * (upper.percent - lower.percent);
            }

            /**
             * Translate preview scroll percentage to editor line using linear interpolation
             */
            previewPercentToLine(percent) {
                if (!this.valid) this.build();
                if (!this.map || this.map.length === 0) return null;

                // Clamp percent
                percent = Math.max(0, Math.min(1, percent));

                // Edge cases
                if (percent <= this.map[0].percent) return this.map[0].line;
                if (percent >= this.map[this.map.length - 1].percent) return this.map[this.map.length - 1].line;

                // Binary search for the bracket
                const lowerIdx = this.binarySearchByPercent(percent);
                if (lowerIdx < 0) return this.map[0].line;

                const upperIdx = lowerIdx + 1;
                if (upperIdx >= this.map.length) return this.map[lowerIdx].line;

                const lower = this.map[lowerIdx];
                const upper = this.map[upperIdx];

                // Exact match
                if (lower.percent === percent) return lower.line;

                // Linear interpolation
                const percentRange = upper.percent - lower.percent;
                if (percentRange === 0) return lower.line;

                const ratio = (percent - lower.percent) / percentRange;
                return lower.line + ratio * (upper.line - lower.line);
            }
        }

        // Scroll sync state
        const syncScrollMap = new SyncScrollMap();
        let ignoreNextEditorScroll = false;
        let ignoreNextPreviewScroll = false;
        let editorScrollTimeoutId = null;
        let previewScrollTimeoutId = null;
        let resizeObserver = null;

        // Debounce delay for scroll events (ms)
        const SCROLL_SYNC_DEBOUNCE = 10;

        /**
         * Get editor scroll position as percentage (0 to 1)
         */
        function getEditorScrollPercent() {
            const scrollHeight = markdownInput.scrollHeight - markdownInput.clientHeight;
            if (scrollHeight <= 0) return 0;
            return markdownInput.scrollTop / scrollHeight;
        }

        /**
         * Set editor scroll position from percentage
         */
        function setEditorScrollPercent(percent) {
            const scrollHeight = markdownInput.scrollHeight - markdownInput.clientHeight;
            markdownInput.scrollTop = percent * scrollHeight;
        }

        /**
         * Get preview scroll position as percentage (0 to 1)
         */
        function getPreviewScrollPercent() {
            const scrollHeight = markdownPreview.scrollHeight - markdownPreview.clientHeight;
            if (scrollHeight <= 0) return 0;
            return markdownPreview.scrollTop / scrollHeight;
        }

        /**
         * Set preview scroll position from percentage
         */
        function setPreviewScrollPercent(percent) {
            const scrollHeight = markdownPreview.scrollHeight - markdownPreview.clientHeight;
            markdownPreview.scrollTop = percent * scrollHeight;
        }

        /**
         * Get editor line height (approximate)
         */
        function getEditorLineHeight() {
            const style = window.getComputedStyle(markdownInput);
            const lineHeight = parseFloat(style.lineHeight);
            if (!isNaN(lineHeight) && lineHeight > 0) return lineHeight;
            const fontSize = parseFloat(style.fontSize) || 14;
            return fontSize * 1.4;
        }

        /**
         * Convert editor scroll percent to approximate line number
         */
        function editorPercentToLine(percent) {
            const lineHeight = getEditorLineHeight();
            const scrollHeight = markdownInput.scrollHeight - markdownInput.clientHeight;
            if (scrollHeight <= 0) return 0;
            const scrollTop = percent * scrollHeight;
            return scrollTop / lineHeight;
        }

        /**
         * Convert editor line to scroll percent
         */
        function editorLineToPercent(line) {
            const lineHeight = getEditorLineHeight();
            const scrollHeight = markdownInput.scrollHeight - markdownInput.clientHeight;
            if (scrollHeight <= 0) return 0;
            return (line * lineHeight) / scrollHeight;
        }

        /**
         * Sync preview scroll when editor scrolls
         */
        function syncEditorToPreview() {
            if (!layoutToggle.checked) return;

            // Check if we should ignore this event (caused by programmatic scroll)
            if (ignoreNextEditorScroll) {
                ignoreNextEditorScroll = false;
                return;
            }

            // Debounce
            if (editorScrollTimeoutId) {
                clearTimeout(editorScrollTimeoutId);
            }

            editorScrollTimeoutId = setTimeout(() => {
                editorScrollTimeoutId = null;

                // Get current editor line from scroll percent
                const editorPercent = getEditorScrollPercent();
                const currentLine = editorPercentToLine(editorPercent);

                // Translate to preview percent
                const previewPercent = syncScrollMap.lineToPreviewPercent(currentLine);
                if (previewPercent === null) return;

                // Set flag to ignore the resulting scroll event
                ignoreNextPreviewScroll = true;

                // Apply scroll
                setPreviewScrollPercent(previewPercent);

                // Reset ignore flag after scroll event has fired
                setTimeout(() => { ignoreNextPreviewScroll = false; }, 50);
            }, SCROLL_SYNC_DEBOUNCE);
        }

        /**
         * Sync editor scroll when preview scrolls
         */
        function syncPreviewToEditor() {
            if (!layoutToggle.checked) return;

            // Check if we should ignore this event
            if (ignoreNextPreviewScroll) {
                ignoreNextPreviewScroll = false;
                return;
            }

            // Debounce
            if (previewScrollTimeoutId) {
                clearTimeout(previewScrollTimeoutId);
            }

            previewScrollTimeoutId = setTimeout(() => {
                previewScrollTimeoutId = null;

                // Get current preview scroll percent
                const previewPercent = getPreviewScrollPercent();

                // Translate to editor line, then to editor percent
                const targetLine = syncScrollMap.previewPercentToLine(previewPercent);
                if (targetLine === null) return;

                const editorPercent = editorLineToPercent(targetLine);

                // Set flag to ignore the resulting scroll event
                ignoreNextEditorScroll = true;

                // Apply scroll
                setEditorScrollPercent(editorPercent);

                // Reset ignore flag after scroll event has fired
                setTimeout(() => { ignoreNextEditorScroll = false; }, 50);
            }, SCROLL_SYNC_DEBOUNCE);
        }

        /**
         * Initialize scroll sync with ResizeObserver for automatic map invalidation
         */
        function initScrollSync() {
            // Build initial map
            syncScrollMap.build();

            // Set up ResizeObserver to detect when preview content changes size
            if (window.ResizeObserver) {
                resizeObserver = new ResizeObserver(() => {
                    // Invalidate map when size changes (images loaded, etc.)
                    syncScrollMap.invalidate();
                });
                resizeObserver.observe(markdownPreview);
            }

            // Add scroll listeners
            markdownInput.addEventListener('scroll', syncEditorToPreview);
            markdownPreview.addEventListener('scroll', syncPreviewToEditor);
        }

        /**
         * Remove scroll sync and clean up
         */
        function removeScrollSync() {
            markdownInput.removeEventListener('scroll', syncEditorToPreview);
            markdownPreview.removeEventListener('scroll', syncPreviewToEditor);

            if (resizeObserver) {
                resizeObserver.disconnect();
                resizeObserver = null;
            }

            // Clear any pending timeouts
            if (editorScrollTimeoutId) clearTimeout(editorScrollTimeoutId);
            if (previewScrollTimeoutId) clearTimeout(previewScrollTimeoutId);
            editorScrollTimeoutId = null;
            previewScrollTimeoutId = null;

            // Reset flags
            ignoreNextEditorScroll = false;
            ignoreNextPreviewScroll = false;

            syncScrollMap.invalidate();
        }

        /**
         * Invalidate scroll sync map (call after rendering)
         */
        function invalidateScrollSyncMap() {
            syncScrollMap.invalidate();
        }

        // =====================================================
        // THEME HANDLING
        // =====================================================

        function setTheme(isDark) {
            const mermaidConfig = {
                startOnLoad: false,
                theme: isDark ? 'dark' : 'default',
                flowchart: { useMaxWidth: true, htmlLabels: true },
                sequence: { useMaxWidth: true },
                gantt: { useMaxWidth: true },
                journey: { useMaxWidth: true },
                class: { useMaxWidth: true },
                state: { useMaxWidth: true },
                er: { useMaxWidth: true },
                pie: { useMaxWidth: true }
            };

            if (isDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeStylesheet.href = THEME_DARK;
            } else {
                document.documentElement.removeAttribute('data-theme');
                themeStylesheet.href = THEME_LIGHT;
            }

            mermaid.initialize(mermaidConfig);
            renderMarkdown();
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }

        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                themeToggle.checked = true;
                setTheme(true);
            }
        }

        // =====================================================
        // LAYOUT TOGGLE
        // =====================================================

        function toggleLayout() {
            const isSideBySide = layoutToggle.checked;

            if (isSideBySide) {
                document.body.classList.add('mode-side-by-side');
                editorContainer.style.flex = '0 0 50%';
                initScrollSync();
            } else {
                document.body.classList.remove('mode-side-by-side');
                editorContainer.style.flex = '';
                removeScrollSync();
            }
        }

        // =====================================================
        // RESIZABLE DIVIDER
        // =====================================================

        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        function startResize(e) {
            if (!layoutToggle.checked) return;
            isResizing = true;
            startX = e.clientX || e.touches[0].clientX;
            startWidth = editorContainer.offsetWidth;
            document.body.classList.add('resizing');
            resizeDivider.classList.add('dragging');

            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
            document.addEventListener('touchmove', doResize);
            document.addEventListener('touchend', stopResize);
        }

        function doResize(e) {
            if (!isResizing) return;
            e.preventDefault();

            const clientX = e.clientX || e.touches[0].clientX;
            const container = document.querySelector('.view-mode-container');
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width;

            const newWidth = startWidth + (clientX - startX);
            const minWidth = containerWidth * 0.2;
            const maxWidth = containerWidth * 0.8;

            const clampedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
            const percentage = (clampedWidth / containerWidth) * 100;

            editorContainer.style.flex = `0 0 ${percentage}%`;
        }

        function stopResize() {
            isResizing = false;
            document.body.classList.remove('resizing');
            resizeDivider.classList.remove('dragging');

            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
            document.removeEventListener('touchmove', doResize);
            document.removeEventListener('touchend', stopResize);

            // Rebuild scroll sync map after resize
            if (layoutToggle.checked) {
                syncScrollMap.invalidate();
                syncScrollMap.build();
            }
        }

        // =====================================================
        // MERMAID DIAGRAM RESIZING
        // =====================================================

        let mermaidResizing = false;
        let mermaidResizeTarget = null;
        let mermaidStartX = 0;
        let mermaidStartWidth = 0;

        /**
         * Initialize Mermaid resize handles after rendering
         * Uses event delegation on the preview container
         */
        function initMermaidResizeHandlers() {
            // Use event delegation - listen on preview container
            markdownPreview.addEventListener('mousedown', handleMermaidResizeStart);
            markdownPreview.addEventListener('touchstart', handleMermaidResizeStart);
        }

        function handleMermaidResizeStart(e) {
            const handle = e.target.closest('.mermaid-resize-handle');
            if (!handle) return;

            e.preventDefault();
            mermaidResizing = true;
            mermaidResizeTarget = handle.closest('.mermaid-container');
            mermaidStartX = e.clientX || e.touches[0].clientX;
            mermaidStartWidth = mermaidResizeTarget.offsetWidth;

            document.body.classList.add('resizing-mermaid');
            handle.classList.add('dragging');

            document.addEventListener('mousemove', handleMermaidResize);
            document.addEventListener('mouseup', handleMermaidResizeEnd);
            document.addEventListener('touchmove', handleMermaidResize);
            document.addEventListener('touchend', handleMermaidResizeEnd);
        }

        function handleMermaidResize(e) {
            if (!mermaidResizing || !mermaidResizeTarget) return;
            e.preventDefault();

            const clientX = e.clientX || e.touches[0].clientX;
            const delta = clientX - mermaidStartX;
            const newWidth = Math.max(200, Math.min(1200, mermaidStartWidth + delta));

            mermaidResizeTarget.style.width = `${newWidth}px`;

            // Update the width indicator
            const indicator = mermaidResizeTarget.querySelector('.mermaid-width-indicator');
            if (indicator) {
                indicator.textContent = `${Math.round(newWidth)}px`;
            }
        }

        function handleMermaidResizeEnd() {
            if (!mermaidResizing) return;

            const handle = mermaidResizeTarget?.querySelector('.mermaid-resize-handle');
            if (handle) {
                handle.classList.remove('dragging');
            }

            mermaidResizing = false;
            mermaidResizeTarget = null;
            document.body.classList.remove('resizing-mermaid');

            document.removeEventListener('mousemove', handleMermaidResize);
            document.removeEventListener('mouseup', handleMermaidResizeEnd);
            document.removeEventListener('touchmove', handleMermaidResize);
            document.removeEventListener('touchend', handleMermaidResizeEnd);

            // Rebuild scroll sync map after mermaid resize
            if (layoutToggle.checked) {
                syncScrollMap.invalidate();
                syncScrollMap.build();
            }
        }

        // =====================================================
        // MARKDOWN LINTING
        // =====================================================

        function lintMarkdown(content) {
            if (!content.trim()) {
                return { status: 'valid', message: 'Valid markdown - No issues detected' };
            }

            const issues = [];
            const lines = content.split('\n');

            // Check for mismatched header levels
            const headerMatches = content.match(/^#{1,6}\s/gm);
            if (headerMatches) {
                const headerLevels = headerMatches.map(h => h.trim().split(' ')[0].length);
                for (let i = 1; i < headerLevels.length; i++) {
                    if (headerLevels[i] - headerLevels[i - 1] > 1) {
                        issues.push('Skipped header level detected');
                        break;
                    }
                }
            }

            // Check for unclosed code blocks
            const codeBlockMatches = content.match(/```/g);
            if (codeBlockMatches && codeBlockMatches.length % 2 !== 0) {
                return { status: 'error', message: 'Syntax error - Unclosed code block detected' };
            }

            // Check for unclosed inline code
            const inlineCodeMatches = content.match(/`/g);
            if (inlineCodeMatches) {
                let count = 0;
                for (let line of lines) {
                    if (line.trim().startsWith('```')) continue;
                    const backticks = (line.match(/`/g) || []).length;
                    count += backticks;
                }
                if (!codeBlockMatches && count % 2 !== 0) {
                    return { status: 'error', message: 'Syntax error - Unclosed inline code detected' };
                }
            }

            // Check for malformed links
            const malformedLinks = content.match(/\[[^\]]*\]\([^)]*$/gm);
            if (malformedLinks) {
                return { status: 'error', message: 'Syntax error - Malformed link detected' };
            }

            // Check for inconsistent list formatting
            const listItems = content.match(/^\s*[-*+]\s/gm);
            if (listItems) {
                const markers = listItems.map(item => item.trim()[0]);
                const uniqueMarkers = [...new Set(markers)];
                if (uniqueMarkers.length > 1) {
                    issues.push('Inconsistent list markers');
                }
            }

            // Check for multiple consecutive blank lines
            if (content.match(/\n\s*\n\s*\n/)) {
                issues.push('Multiple consecutive blank lines');
            }

            // Check for trailing spaces
            const trailingSpaces = lines.filter(line => line.match(/\s+$/));
            if (trailingSpaces.length > 2) {
                issues.push('Excessive trailing spaces');
            }

            if (issues.length === 0) {
                return { status: 'valid', message: 'Valid markdown - No issues detected' };
            } else {
                return { status: 'warning', message: `Minor formatting issues - ${issues.join(', ')}` };
            }
        }

        function updateStatus(lintResult) {
            statusIndicator.className = 'status-indicator';

            switch (lintResult.status) {
                case 'valid':
                    statusIndicator.classList.add('status-valid');
                    break;
                case 'warning':
                    statusIndicator.classList.add('status-warning');
                    break;
                case 'error':
                    statusIndicator.classList.add('status-error');
                    break;
            }

            statusIndicator.textContent = lintResult.message;
        }

        // =====================================================
        // RENDER MARKDOWN
        // =====================================================

        function renderMarkdown() {
            const content = markdownInput.value;

            // Lint the markdown
            const lintResult = lintMarkdown(content);
            updateStatus(lintResult);

            // Render empty state
            if (!content.trim()) {
                markdownPreview.innerHTML = '<div class="empty-state">Your rendered markdown will appear here...</div>';
                invalidateScrollSyncMap();
                return;
            }

            try {
                // Render using markdown-it
                const html = md.render(content);
                markdownPreview.innerHTML = html;

                // Initialize Mermaid diagrams
                mermaid.run({
                    nodes: document.querySelectorAll('.mermaid')
                });

                // Invalidate and rebuild scroll sync map after render
                syncScrollMap.invalidate();
                if (layoutToggle.checked) {
                    // Delay slightly to allow DOM to settle
                    setTimeout(() => {
                        syncScrollMap.build();
                    }, 100);
                }
            } catch (error) {
                markdownPreview.innerHTML = `<div class="alert alert-danger">
                    <strong>Rendering Error:</strong> ${error.message}
                </div>`;
                updateStatus({ status: 'error', message: 'Syntax error - Failed to render markdown' });
            }
        }

        function debouncedRender() {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(renderMarkdown, 300);
        }

        function clearEditor() {
            markdownInput.value = '';
            renderMarkdown();
            markdownInput.focus();
        }

        // =====================================================
        // EVENT LISTENERS
        // =====================================================

        markdownInput.addEventListener('input', debouncedRender);
        clearBtn.addEventListener('click', clearEditor);
        rerenderBtn.addEventListener('click', renderMarkdown);

        layoutToggle.addEventListener('change', toggleLayout);
        themeToggle.addEventListener('change', () => setTheme(themeToggle.checked));

        resizeDivider.addEventListener('mousedown', startResize);
        resizeDivider.addEventListener('touchstart', startResize);

        // Initialize Mermaid resize handlers (event delegation)
        initMermaidResizeHandlers();

        // Load saved theme preference
        loadSavedTheme();

        // Initial render
        renderMarkdown();

        // Fallback check for markdown-it
        if (typeof window.markdownit === 'undefined') {
            markdownPreview.innerHTML = `
                <div class="alert alert-danger">
                    <strong>Error:</strong> Failed to load markdown-it library. Please check your internet connection.
                </div>
            `;
        }
    </script>
</body>
</html>
