<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>View Scrubbai - Markdown Viewer & Editor</title>

    <!-- Bootswatch Theme CSS (Flatly for light, Darkly for dark) -->
    <link id="theme-stylesheet" href="https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/flatly/bootstrap.min.css" rel="stylesheet">

    <!-- markdown-it Library (replacing marked.js for better source map support) -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"></script>

    <!-- Mermaid.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>

    <style>
        /* Light theme (Flatly) custom properties */
        :root {
            --viewer-bg: #ecf0f1;
            --viewer-card-bg: #ffffff;
            --viewer-text: #2c3e50;
            --viewer-text-muted: #7b8a8b;
            --viewer-border: #dce4ec;
            --viewer-primary: #2c3e50;
            --viewer-accent: #18bc9c;
            --viewer-code-bg: #ecf0f1;
            --viewer-pre-bg: #2c3e50;
            --viewer-pre-text: #ecf0f1;
            --viewer-link: #18bc9c;
            --viewer-table-header: #2c3e50;
            --viewer-table-stripe: #f8f9fa;
            --viewer-shadow: rgba(0, 0, 0, 0.08);
            --viewer-divider-bg: #bdc3c7;
            --viewer-divider-hover: #95a5a6;
        }

        /* Dark theme (Darkly) custom properties */
        [data-theme="dark"] {
            --viewer-bg: #222222;
            --viewer-card-bg: #303030;
            --viewer-text: #ffffff;
            --viewer-text-muted: #adb5bd;
            --viewer-border: #444444;
            --viewer-primary: #00bc8c;
            --viewer-accent: #00bc8c;
            --viewer-code-bg: #444444;
            --viewer-pre-bg: #1a1a1a;
            --viewer-pre-text: #ffffff;
            --viewer-link: #00bc8c;
            --viewer-table-header: #00bc8c;
            --viewer-table-stripe: #3a3a3a;
            --viewer-shadow: rgba(0, 0, 0, 0.3);
            --viewer-divider-bg: #555555;
            --viewer-divider-hover: #00bc8c;
        }

        body {
            background-color: var(--viewer-bg);
            color: var(--viewer-text);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .header {
            background: var(--viewer-card-bg);
            color: var(--viewer-primary);
            padding: 1.5rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px var(--viewer-shadow);
            border-bottom: 3px solid var(--viewer-accent);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .header h1 {
            font-weight: 600;
            margin: 0;
            font-size: 2rem;
            color: var(--viewer-primary);
        }

        .header p {
            margin: 0.5rem 0 0 0;
            color: var(--viewer-text-muted);
            font-size: 0.95rem;
        }

        .editor-container {
            background: var(--viewer-card-bg);
            border-radius: 8px;
            padding: 2rem;
            box-shadow: 0 2px 8px var(--viewer-shadow);
            margin-bottom: 2rem;
            transition: background-color 0.3s ease;
        }

        .textarea-wrapper {
            position: relative;
            margin-bottom: 1.5rem;
        }

        #markdownInput {
            width: 100%;
            min-height: 400px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border: 2px solid var(--viewer-border);
            border-radius: 6px;
            padding: 1rem;
            resize: vertical;
            transition: border-color 0.3s ease, background-color 0.3s ease, color 0.3s ease;
            background-color: var(--viewer-card-bg);
            color: var(--viewer-text);
        }

        #markdownInput:focus {
            outline: none;
            border-color: var(--viewer-accent);
            box-shadow: 0 0 0 0.2rem rgba(24, 188, 156, 0.25);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 1.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .status-indicator::before {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.75rem;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-valid {
            background-color: rgba(0, 188, 140, 0.15);
            color: #00bc8c;
            border: 1px solid rgba(0, 188, 140, 0.4);
        }

        .status-valid::before {
            background-color: #00bc8c;
        }

        .status-warning {
            background-color: rgba(243, 156, 18, 0.15);
            color: #f39c12;
            border: 1px solid rgba(243, 156, 18, 0.4);
        }

        .status-warning::before {
            background-color: #f39c12;
        }

        .status-error {
            background-color: rgba(231, 76, 60, 0.15);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.4);
        }

        .status-error::before {
            background-color: #e74c3c;
        }

        .button-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .preview-container {
            background: var(--viewer-card-bg);
            border-radius: 8px;
            padding: 2rem;
            box-shadow: 0 2px 8px var(--viewer-shadow);
            min-height: 300px;
            transition: background-color 0.3s ease;
        }

        .preview-header {
            color: var(--viewer-primary);
            font-weight: 600;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--viewer-accent);
        }

        #markdownPreview {
            line-height: 1.6;
            color: var(--viewer-text);
        }

        /* Styled Markdown Output */
        #markdownPreview h1,
        #markdownPreview h2,
        #markdownPreview h3,
        #markdownPreview h4,
        #markdownPreview h5,
        #markdownPreview h6 {
            color: var(--viewer-primary);
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        #markdownPreview h1 {
            font-size: 2rem;
            border-bottom: 3px solid var(--viewer-accent);
            padding-bottom: 0.5rem;
        }

        #markdownPreview h2 {
            font-size: 1.75rem;
            border-bottom: 2px solid var(--viewer-border);
            padding-bottom: 0.4rem;
        }

        #markdownPreview h3 {
            font-size: 1.5rem;
        }

        #markdownPreview p {
            margin-bottom: 1rem;
        }

        #markdownPreview code {
            background-color: var(--viewer-code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--viewer-accent);
        }

        #markdownPreview pre {
            background-color: var(--viewer-pre-bg);
            color: var(--viewer-pre-text);
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        #markdownPreview pre code {
            background-color: transparent;
            color: var(--viewer-pre-text);
            padding: 0;
        }

        #markdownPreview blockquote {
            border-left: 4px solid var(--viewer-accent);
            padding-left: 1rem;
            margin-left: 0;
            color: var(--viewer-text-muted);
        }

        #markdownPreview a {
            color: var(--viewer-link);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.3s ease;
        }

        #markdownPreview a:hover {
            border-bottom-color: var(--viewer-link);
        }

        #markdownPreview ul,
        #markdownPreview ol {
            margin-bottom: 1rem;
            padding-left: 2rem;
        }

        #markdownPreview li {
            margin-bottom: 0.5rem;
        }

        #markdownPreview table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        #markdownPreview th,
        #markdownPreview td {
            border: 1px solid var(--viewer-border);
            padding: 0.75rem;
            text-align: left;
        }

        #markdownPreview th {
            background-color: var(--viewer-table-header);
            color: white;
            font-weight: 600;
        }

        #markdownPreview tr:nth-child(even) {
            background-color: var(--viewer-table-stripe);
        }

        #markdownPreview img {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            margin: 1rem 0;
        }

        #markdownPreview hr {
            border: 0;
            height: 2px;
            background: var(--viewer-accent);
            margin: 2rem 0;
        }

        .empty-state {
            text-align: left;
            color: var(--viewer-text-muted);
            padding: 3rem 0;
        }

        footer {
            text-align: left;
            padding: 2rem 0;
            color: var(--viewer-text-muted);
            font-size: 0.9rem;
        }

        /* Form label styling */
        .form-label {
            color: var(--viewer-primary);
        }

        /* Theme toggle styling */
        .theme-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .theme-toggle .form-check-input {
            width: 3rem;
            height: 1.5rem;
        }

        .theme-icon {
            font-size: 1.2rem;
        }

        /* Side-by-Side Layout Styles */
        .mode-side-by-side .view-mode-container {
            display: flex;
            align-items: stretch;
            height: calc(100vh - 180px);
            min-height: 500px;
            gap: 0;
        }

        .mode-side-by-side .editor-container {
            flex: 0 0 50%;
            margin-bottom: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-radius: 8px 0 0 8px;
        }

        .mode-side-by-side .preview-container {
            flex: 1;
            margin-bottom: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-radius: 0 8px 8px 0;
        }

        /* Resizable Divider */
        .resize-divider {
            display: none;
            width: 8px;
            background-color: var(--viewer-divider-bg);
            cursor: col-resize;
            flex-shrink: 0;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .resize-divider:hover,
        .resize-divider.dragging {
            background-color: var(--viewer-divider-hover);
        }

        .resize-divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 40px;
            background: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 3px,
                var(--viewer-card-bg) 3px,
                var(--viewer-card-bg) 6px
            );
            border-radius: 2px;
        }

        .mode-side-by-side .resize-divider {
            display: block;
        }

        .mode-side-by-side .textarea-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
        }

        .mode-side-by-side #markdownInput {
            flex: 1;
            resize: none;
            height: 100% !important;
            min-height: 0;
        }

        .mode-side-by-side #markdownPreview {
            overflow-y: auto;
            flex: 1;
            padding-right: 0.5rem;
        }

        /* Custom Scrollbar for side-by-side panels */
        .mode-side-by-side #markdownInput::-webkit-scrollbar,
        .mode-side-by-side #markdownPreview::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .mode-side-by-side #markdownInput::-webkit-scrollbar-track,
        .mode-side-by-side #markdownPreview::-webkit-scrollbar-track {
            background: var(--viewer-bg);
            border-radius: 4px;
        }

        .mode-side-by-side #markdownInput::-webkit-scrollbar-thumb,
        .mode-side-by-side #markdownPreview::-webkit-scrollbar-thumb {
            background: var(--viewer-divider-bg);
            border-radius: 4px;
        }

        .mode-side-by-side #markdownInput::-webkit-scrollbar-thumb:hover,
        .mode-side-by-side #markdownPreview::-webkit-scrollbar-thumb:hover {
            background: var(--viewer-divider-hover);
        }

        /* Hide elements that might clutter side-by-side view if needed */
        .mode-side-by-side .header {
            margin-bottom: 1rem;
        }

        /* Prevent text selection while dragging divider */
        body.resizing {
            user-select: none;
            cursor: col-resize;
        }

        /* Responsive override: Disable side-by-side on small screens */
        @media (max-width: 767.98px) {
            .mode-side-by-side .view-mode-container {
                display: block;
                height: auto;
            }
            .mode-side-by-side .editor-container,
            .mode-side-by-side .preview-container {
                width: 100% !important;
                flex: none;
                overflow: visible;
                height: auto;
                border-radius: 8px;
            }
            .mode-side-by-side .editor-container {
                margin-bottom: 2rem;
            }
            .mode-side-by-side #markdownInput {
                height: auto !important;
                resize: vertical;
            }
            .mode-side-by-side #markdownPreview {
                overflow-y: visible;
            }
            .mode-side-by-side .resize-divider {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="container d-flex justify-content-between align-items-center flex-wrap">
            <div>
                <h1>View Scrubbai</h1>
                <p>Professional Markdown Viewer & Editor</p>
            </div>
            <div class="settings-panel d-flex align-items-center gap-4 mt-3 mt-md-0">
                <div class="form-check form-switch d-none d-md-block">
                    <input class="form-check-input" type="checkbox" id="layoutToggle">
                    <label class="form-check-label" for="layoutToggle">Side-by-Side</label>
                </div>
                <div class="theme-toggle">
                    <span class="theme-icon" id="sunIcon">&#9728;</span>
                    <div class="form-check form-switch mb-0">
                        <input class="form-check-input" type="checkbox" id="themeToggle">
                    </div>
                    <span class="theme-icon" id="moonIcon">&#9790;</span>
                </div>
            </div>
        </div>
    </div>

    <div id="mainContainer" class="container">
        <div class="view-mode-container">
            <div class="editor-container">
                <div class="textarea-wrapper">
                    <label for="markdownInput" class="form-label fw-bold">
                        Markdown Editor
                    </label>
                    <textarea
                        id="markdownInput"
                        class="form-control"
                        rows="20"
                        placeholder="Type or paste your markdown here...&#10;&#10;# Example Heading&#10;&#10;This is a **bold** statement with *italic* text.&#10;&#10;- List item 1&#10;- List item 2&#10;&#10;```javascript&#10;console.log('Hello, World!');&#10;```&#10;&#10;```mermaid&#10;graph TD;&#10;    A-->B;&#10;```"
                    ></textarea>
                </div>

                <div id="statusIndicator" class="status-indicator status-valid">
                    Valid markdown - No issues detected
                </div>

                <div class="button-group">
                    <button id="clearBtn" class="btn btn-outline-secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16" style="margin-right: 0.5rem; vertical-align: text-bottom;">
                            <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                            <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/>
                        </svg>
                        Clear
                    </button>
                    <button id="rerenderBtn" class="btn btn-primary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-clockwise" viewBox="0 0 16 16" style="margin-right: 0.5rem; vertical-align: text-bottom;">
                            <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
                            <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
                        </svg>
                        Re-render
                    </button>
                </div>
            </div>

            <div class="resize-divider" id="resizeDivider"></div>

            <div class="preview-container">
                <h2 class="preview-header fw-bold" style="font-size: 1rem; margin-bottom: 0.5rem; border-bottom: none; padding-bottom: 0;">
                    Preview
                </h2>
                <div id="markdownPreview" class="empty-state">
                    Your rendered markdown will appear here...
                </div>
            </div>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>&copy; 2024 View Scrubbai. Built with markdown-it and Bootstrap 5.</p>
        </div>
    </footer>

    <!-- Bootstrap 5 JS Bundle (optional for this use case, but included for completeness) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

    <script>
        // =====================================================
        // MARKDOWN-IT CONFIGURATION WITH SOURCE LINE INJECTION
        // =====================================================

        // Initialize markdown-it with GFM-like options
        const md = window.markdownit({
            html: true,
            breaks: true,
            linkify: true,
            typographer: false
        });

        // Store the default fence renderer
        const defaultFenceRenderer = md.renderer.rules.fence || function(tokens, idx, options, env, self) {
            return self.renderToken(tokens, idx, options);
        };

        // Custom fence renderer for Mermaid support
        md.renderer.rules.fence = function(tokens, idx, options, env, self) {
            const token = tokens[idx];
            const info = token.info ? token.info.trim() : '';
            const lang = info.split(/\s+/g)[0];

            if (lang === 'mermaid') {
                const line = token.map ? token.map[0] : 0;
                return `<div class="mermaid" data-source-line="${line}">${md.utils.escapeHtml(token.content)}</div>`;
            }

            // For other code blocks, add source line and use default rendering
            const line = token.map ? token.map[0] : 0;
            const langClass = lang ? ` class="language-${lang}"` : '';
            const escaped = md.utils.escapeHtml(token.content);
            return `<pre data-source-line="${line}"><code${langClass}>${escaped}</code></pre>`;
        };

        // Inject source line numbers into block-level elements (VS Code approach)
        // This adds data-source-line attributes to rendered HTML for scroll sync
        md.core.ruler.push('source_line_injector', function(state) {
            for (let i = 0; i < state.tokens.length; i++) {
                const token = state.tokens[i];
                // Add line info to block tokens that have map info
                if (token.map && token.nesting >= 0) {
                    token.attrSet('data-source-line', String(token.map[0]));
                    token.attrJoin('class', 'source-line');
                }
            }
        });

        // Initialize Mermaid
        mermaid.initialize({ startOnLoad: false });

        // =====================================================
        // DOM ELEMENTS
        // =====================================================

        const markdownInput = document.getElementById('markdownInput');
        const markdownPreview = document.getElementById('markdownPreview');
        const statusIndicator = document.getElementById('statusIndicator');
        const clearBtn = document.getElementById('clearBtn');
        const rerenderBtn = document.getElementById('rerenderBtn');

        const layoutToggle = document.getElementById('layoutToggle');
        const mainContainer = document.getElementById('mainContainer');
        const themeToggle = document.getElementById('themeToggle');
        const themeStylesheet = document.getElementById('theme-stylesheet');
        const resizeDivider = document.getElementById('resizeDivider');
        const editorContainer = document.querySelector('.editor-container');
        const previewContainer = document.querySelector('.preview-container');

        // Theme URLs
        const THEME_LIGHT = 'https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/flatly/bootstrap.min.css';
        const THEME_DARK = 'https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/darkly/bootstrap.min.css';

        // Debounce timer
        let debounceTimer;

        // =====================================================
        // SCROLL SYNC WITH SOURCE LINE MAPPING & INTERPOLATION
        // =====================================================

        // Cache for scroll sync mapping (rebuilt on render)
        let scrollSyncMap = null;

        /**
         * Build a mapping between editor lines and preview element positions
         * This enables accurate scroll synchronization
         */
        function buildScrollSyncMap() {
            const elements = markdownPreview.querySelectorAll('[data-source-line]');
            const map = [];

            elements.forEach(el => {
                const line = parseInt(el.getAttribute('data-source-line'), 10);
                const rect = el.getBoundingClientRect();
                const previewRect = markdownPreview.getBoundingClientRect();
                // Position relative to preview container's scroll
                const top = rect.top - previewRect.top + markdownPreview.scrollTop;
                map.push({ line, top, element: el });
            });

            // Sort by line number
            map.sort((a, b) => a.line - b.line);

            return map;
        }

        /**
         * Get the line height in the editor (approximate)
         */
        function getEditorLineHeight() {
            const style = window.getComputedStyle(markdownInput);
            const lineHeight = parseFloat(style.lineHeight);
            if (!isNaN(lineHeight)) return lineHeight;
            // Fallback: estimate based on font size
            const fontSize = parseFloat(style.fontSize);
            return fontSize * 1.4;
        }

        /**
         * Get the current line number at the top of the editor viewport
         */
        function getEditorTopLine() {
            const lineHeight = getEditorLineHeight();
            const scrollTop = markdownInput.scrollTop;
            return scrollTop / lineHeight;
        }

        /**
         * Calculate preview scroll position for a given editor line using interpolation
         */
        function getPreviewScrollForLine(line) {
            if (!scrollSyncMap || scrollSyncMap.length === 0) {
                return null;
            }

            // Find surrounding mapped elements for interpolation
            let before = null;
            let after = null;

            for (let i = 0; i < scrollSyncMap.length; i++) {
                if (scrollSyncMap[i].line <= line) {
                    before = scrollSyncMap[i];
                }
                if (scrollSyncMap[i].line >= line && after === null) {
                    after = scrollSyncMap[i];
                }
            }

            // Edge cases
            if (!before && !after) return 0;
            if (!before) return after.top;
            if (!after) return before.top;
            if (before === after) return before.top;

            // Linear interpolation between the two anchor points
            const lineRange = after.line - before.line;
            const posRange = after.top - before.top;
            const lineDelta = line - before.line;
            const ratio = lineRange > 0 ? lineDelta / lineRange : 0;

            return before.top + (ratio * posRange);
        }

        /**
         * Calculate editor scroll position for a given preview scroll position using interpolation
         */
        function getEditorScrollForPreviewPosition(previewScrollTop) {
            if (!scrollSyncMap || scrollSyncMap.length === 0) {
                return null;
            }

            // Find surrounding mapped elements for interpolation
            let before = null;
            let after = null;

            for (let i = 0; i < scrollSyncMap.length; i++) {
                if (scrollSyncMap[i].top <= previewScrollTop) {
                    before = scrollSyncMap[i];
                }
                if (scrollSyncMap[i].top >= previewScrollTop && after === null) {
                    after = scrollSyncMap[i];
                }
            }

            // Edge cases
            if (!before && !after) return 0;
            if (!before) return after.line * getEditorLineHeight();
            if (!after) return before.line * getEditorLineHeight();
            if (before === after) return before.line * getEditorLineHeight();

            // Linear interpolation between the two anchor points
            const posRange = after.top - before.top;
            const lineRange = after.line - before.line;
            const posDelta = previewScrollTop - before.top;
            const ratio = posRange > 0 ? posDelta / posRange : 0;

            const targetLine = before.line + (ratio * lineRange);
            return targetLine * getEditorLineHeight();
        }

        // Scroll sync state
        let isSyncingFromEditor = false;
        let isSyncingFromPreview = false;
        let scrollSyncAnimationFrame = null;

        /**
         * Sync preview scroll when editor scrolls (with interpolation)
         */
        function syncEditorToPreview() {
            if (!layoutToggle.checked) return;
            if (isSyncingFromPreview) {
                isSyncingFromPreview = false;
                return;
            }

            // Cancel any pending animation frame
            if (scrollSyncAnimationFrame) {
                cancelAnimationFrame(scrollSyncAnimationFrame);
            }

            scrollSyncAnimationFrame = requestAnimationFrame(() => {
                isSyncingFromEditor = true;

                // Rebuild map if needed (could cache and invalidate on render)
                if (!scrollSyncMap) {
                    scrollSyncMap = buildScrollSyncMap();
                }

                const currentLine = getEditorTopLine();
                const targetScroll = getPreviewScrollForLine(currentLine);

                if (targetScroll !== null) {
                    markdownPreview.scrollTop = targetScroll;
                }

                // Reset flag after a short delay to allow the scroll event to fire
                setTimeout(() => { isSyncingFromEditor = false; }, 50);
            });
        }

        /**
         * Sync editor scroll when preview scrolls (with interpolation)
         */
        function syncPreviewToEditor() {
            if (!layoutToggle.checked) return;
            if (isSyncingFromEditor) {
                isSyncingFromEditor = false;
                return;
            }

            // Cancel any pending animation frame
            if (scrollSyncAnimationFrame) {
                cancelAnimationFrame(scrollSyncAnimationFrame);
            }

            scrollSyncAnimationFrame = requestAnimationFrame(() => {
                isSyncingFromPreview = true;

                // Rebuild map if needed
                if (!scrollSyncMap) {
                    scrollSyncMap = buildScrollSyncMap();
                }

                const targetScroll = getEditorScrollForPreviewPosition(markdownPreview.scrollTop);

                if (targetScroll !== null) {
                    markdownInput.scrollTop = targetScroll;
                }

                // Reset flag after a short delay
                setTimeout(() => { isSyncingFromPreview = false; }, 50);
            });
        }

        /**
         * Invalidate scroll sync map (call after rendering)
         */
        function invalidateScrollSyncMap() {
            scrollSyncMap = null;
        }

        function initScrollSync() {
            // Rebuild map after layout settles
            setTimeout(() => {
                scrollSyncMap = buildScrollSyncMap();
            }, 100);

            markdownInput.addEventListener('scroll', syncEditorToPreview);
            markdownPreview.addEventListener('scroll', syncPreviewToEditor);
        }

        function removeScrollSync() {
            markdownInput.removeEventListener('scroll', syncEditorToPreview);
            markdownPreview.removeEventListener('scroll', syncPreviewToEditor);

            isSyncingFromEditor = false;
            isSyncingFromPreview = false;
            scrollSyncMap = null;
        }

        // =====================================================
        // THEME HANDLING
        // =====================================================

        function setTheme(isDark) {
            if (isDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeStylesheet.href = THEME_DARK;
                mermaid.initialize({ startOnLoad: false, theme: 'dark' });
            } else {
                document.documentElement.removeAttribute('data-theme');
                themeStylesheet.href = THEME_LIGHT;
                mermaid.initialize({ startOnLoad: false, theme: 'default' });
            }
            renderMarkdown();
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }

        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                themeToggle.checked = true;
                setTheme(true);
            }
        }

        // =====================================================
        // LAYOUT TOGGLE
        // =====================================================

        function toggleLayout() {
            const isSideBySide = layoutToggle.checked;

            if (isSideBySide) {
                document.body.classList.add('mode-side-by-side');
                editorContainer.style.flex = '0 0 50%';
                initScrollSync();
            } else {
                document.body.classList.remove('mode-side-by-side');
                editorContainer.style.flex = '';
                removeScrollSync();
            }
        }

        // =====================================================
        // RESIZABLE DIVIDER
        // =====================================================

        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        function startResize(e) {
            if (!layoutToggle.checked) return;
            isResizing = true;
            startX = e.clientX || e.touches[0].clientX;
            startWidth = editorContainer.offsetWidth;
            document.body.classList.add('resizing');
            resizeDivider.classList.add('dragging');

            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
            document.addEventListener('touchmove', doResize);
            document.addEventListener('touchend', stopResize);
        }

        function doResize(e) {
            if (!isResizing) return;
            e.preventDefault();

            const clientX = e.clientX || e.touches[0].clientX;
            const container = document.querySelector('.view-mode-container');
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width;

            const newWidth = startWidth + (clientX - startX);
            const minWidth = containerWidth * 0.2;
            const maxWidth = containerWidth * 0.8;

            const clampedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
            const percentage = (clampedWidth / containerWidth) * 100;

            editorContainer.style.flex = `0 0 ${percentage}%`;
        }

        function stopResize() {
            isResizing = false;
            document.body.classList.remove('resizing');
            resizeDivider.classList.remove('dragging');

            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
            document.removeEventListener('touchmove', doResize);
            document.removeEventListener('touchend', stopResize);

            // Rebuild scroll sync map after resize
            if (layoutToggle.checked) {
                invalidateScrollSyncMap();
                scrollSyncMap = buildScrollSyncMap();
            }
        }

        // =====================================================
        // MARKDOWN LINTING
        // =====================================================

        function lintMarkdown(content) {
            if (!content.trim()) {
                return { status: 'valid', message: 'Valid markdown - No issues detected' };
            }

            const issues = [];
            const lines = content.split('\n');

            // Check for mismatched header levels
            const headerMatches = content.match(/^#{1,6}\s/gm);
            if (headerMatches) {
                const headerLevels = headerMatches.map(h => h.trim().split(' ')[0].length);
                for (let i = 1; i < headerLevels.length; i++) {
                    if (headerLevels[i] - headerLevels[i - 1] > 1) {
                        issues.push('Skipped header level detected');
                        break;
                    }
                }
            }

            // Check for unclosed code blocks
            const codeBlockMatches = content.match(/```/g);
            if (codeBlockMatches && codeBlockMatches.length % 2 !== 0) {
                return { status: 'error', message: 'Syntax error - Unclosed code block detected' };
            }

            // Check for unclosed inline code
            const inlineCodeMatches = content.match(/`/g);
            if (inlineCodeMatches) {
                let count = 0;
                for (let line of lines) {
                    if (line.trim().startsWith('```')) continue;
                    const backticks = (line.match(/`/g) || []).length;
                    count += backticks;
                }
                if (!codeBlockMatches && count % 2 !== 0) {
                    return { status: 'error', message: 'Syntax error - Unclosed inline code detected' };
                }
            }

            // Check for malformed links
            const malformedLinks = content.match(/\[[^\]]*\]\([^)]*$/gm);
            if (malformedLinks) {
                return { status: 'error', message: 'Syntax error - Malformed link detected' };
            }

            // Check for inconsistent list formatting
            const listItems = content.match(/^\s*[-*+]\s/gm);
            if (listItems) {
                const markers = listItems.map(item => item.trim()[0]);
                const uniqueMarkers = [...new Set(markers)];
                if (uniqueMarkers.length > 1) {
                    issues.push('Inconsistent list markers');
                }
            }

            // Check for multiple consecutive blank lines
            if (content.match(/\n\s*\n\s*\n/)) {
                issues.push('Multiple consecutive blank lines');
            }

            // Check for trailing spaces
            const trailingSpaces = lines.filter(line => line.match(/\s+$/));
            if (trailingSpaces.length > 2) {
                issues.push('Excessive trailing spaces');
            }

            if (issues.length === 0) {
                return { status: 'valid', message: 'Valid markdown - No issues detected' };
            } else {
                return { status: 'warning', message: `Minor formatting issues - ${issues.join(', ')}` };
            }
        }

        function updateStatus(lintResult) {
            statusIndicator.className = 'status-indicator';

            switch (lintResult.status) {
                case 'valid':
                    statusIndicator.classList.add('status-valid');
                    break;
                case 'warning':
                    statusIndicator.classList.add('status-warning');
                    break;
                case 'error':
                    statusIndicator.classList.add('status-error');
                    break;
            }

            statusIndicator.textContent = lintResult.message;
        }

        // =====================================================
        // RENDER MARKDOWN
        // =====================================================

        function renderMarkdown() {
            const content = markdownInput.value;

            // Lint the markdown
            const lintResult = lintMarkdown(content);
            updateStatus(lintResult);

            // Render empty state
            if (!content.trim()) {
                markdownPreview.innerHTML = '<div class="empty-state">Your rendered markdown will appear here...</div>';
                invalidateScrollSyncMap();
                return;
            }

            try {
                // Render using markdown-it
                const html = md.render(content);
                markdownPreview.innerHTML = html;

                // Initialize Mermaid diagrams
                mermaid.run({
                    nodes: document.querySelectorAll('.mermaid')
                });

                // Invalidate and rebuild scroll sync map after render
                invalidateScrollSyncMap();
                if (layoutToggle.checked) {
                    // Delay slightly to allow DOM to settle
                    setTimeout(() => {
                        scrollSyncMap = buildScrollSyncMap();
                    }, 100);
                }
            } catch (error) {
                markdownPreview.innerHTML = `<div class="alert alert-danger">
                    <strong>Rendering Error:</strong> ${error.message}
                </div>`;
                updateStatus({ status: 'error', message: 'Syntax error - Failed to render markdown' });
            }
        }

        function debouncedRender() {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(renderMarkdown, 300);
        }

        function clearEditor() {
            markdownInput.value = '';
            renderMarkdown();
            markdownInput.focus();
        }

        // =====================================================
        // EVENT LISTENERS
        // =====================================================

        markdownInput.addEventListener('input', debouncedRender);
        clearBtn.addEventListener('click', clearEditor);
        rerenderBtn.addEventListener('click', renderMarkdown);

        layoutToggle.addEventListener('change', toggleLayout);
        themeToggle.addEventListener('change', () => setTheme(themeToggle.checked));

        resizeDivider.addEventListener('mousedown', startResize);
        resizeDivider.addEventListener('touchstart', startResize);

        // Load saved theme preference
        loadSavedTheme();

        // Initial render
        renderMarkdown();

        // Fallback check for markdown-it
        if (typeof window.markdownit === 'undefined') {
            markdownPreview.innerHTML = `
                <div class="alert alert-danger">
                    <strong>Error:</strong> Failed to load markdown-it library. Please check your internet connection.
                </div>
            `;
        }
    </script>
</body>
</html>
