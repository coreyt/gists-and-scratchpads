<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>View Scrubbai - Markdown Viewer & Editor</title>

    <!-- Bootswatch Theme CSS (Flatly for light, Darkly for dark) -->
    <link id="theme-stylesheet" href="https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/flatly/bootstrap.min.css" rel="stylesheet">

    <!-- markdown-it Library (replacing marked.js for better source map support) -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"></script>

    <!-- Mermaid.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>

    <style>
        /* Make containers wider - use more viewport width with small gutters */
        .container, .container-fluid {
            max-width: calc(100% - 2rem);
            padding-left: 1rem;
            padding-right: 1rem;
        }

        @media (min-width: 576px) {
            .container, .container-fluid {
                max-width: calc(100% - 3rem);
                padding-left: 1.5rem;
                padding-right: 1.5rem;
            }
        }

        /* Adjust body padding for fixed navbar */
        body {
            padding-top: 70px;
        }

        .editor-container, .preview-container {
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .textarea-wrapper {
            position: relative;
        }

        #markdownInput {
            width: 100%;
            min-height: 400px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        #markdownPreview {
            line-height: 1.6;
        }

        /* Minimal markdown output styling - let Bootstrap handle most */
        #markdownPreview pre {
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
        }

        #markdownPreview blockquote {
            border-left: 4px solid currentColor;
            padding-left: 1rem;
            margin-left: 0;
            opacity: 0.8;
        }

        #markdownPreview table {
            width: 100%;
            margin: 1rem 0;
        }

        #markdownPreview img {
            max-width: 100%;
            height: auto;
        }

        .empty-state {
            padding: 3rem 0;
            opacity: 0.6;
        }

        /* Theme toggle styling */
        .theme-icon {
            font-size: 1.1rem;
        }

        /* Settings dropdown styling */
        .dropdown-menu {
            min-width: 220px;
        }

        /* Swapped sides layout */
        .mode-swapped .view-mode-container {
            flex-direction: row-reverse;
        }

        /* Side-by-Side Layout Styles */
        .mode-side-by-side .view-mode-container {
            display: flex;
            align-items: stretch;
            height: calc(100vh - 140px);
            min-height: 500px;
            gap: 0;
        }

        .mode-side-by-side .editor-container {
            flex: 0 0 50%;
            margin-bottom: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .mode-side-by-side .preview-container {
            flex: 1;
            margin-bottom: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Resizable Divider */
        .resize-divider {
            display: none;
            width: 8px;
            cursor: col-resize;
            flex-shrink: 0;
            position: relative;
        }

        .mode-side-by-side .resize-divider {
            display: block;
        }

        .mode-side-by-side .textarea-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .mode-side-by-side #markdownInput {
            flex: 1;
            resize: none;
            height: 100% !important;
            min-height: 0;
        }

        .mode-side-by-side #markdownPreview {
            overflow-y: auto;
            flex: 1;
        }

        /* Prevent text selection while dragging divider */
        body.resizing {
            user-select: none;
            cursor: col-resize;
        }

        /* Resizable Mermaid Diagram Container */
        .mermaid-container {
            position: relative;
            display: inline-block;
            min-width: 200px;
            max-width: 100%;
            margin: 1rem 0;
            border: 1px solid;
            border-radius: 6px;
            overflow: hidden;
        }

        .mermaid-container .mermaid {
            padding: 1rem;
            overflow: auto;
        }

        .mermaid-container .mermaid svg {
            max-width: 100%;
            height: auto;
            display: block;
        }

        .mermaid-resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 12px;
            cursor: ew-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }

        .mermaid-resize-handle:hover {
            opacity: 1;
        }

        .mermaid-width-indicator {
            position: absolute;
            top: 4px;
            left: 4px;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
            opacity: 0.8;
            pointer-events: none;
        }

        /* Prevent text selection while resizing mermaid */
        body.resizing-mermaid {
            user-select: none;
            cursor: ew-resize;
        }

        /* Highlight errors in textarea */
        .highlight-issues #markdownInput {
            border-color: #dc3545 !important;
            box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25) !important;
        }

        .highlight-issues.has-warning #markdownInput {
            border-color: #ffc107 !important;
            box-shadow: 0 0 0 0.2rem rgba(255, 193, 7, 0.25) !important;
        }

        /* Responsive override: Disable side-by-side on small screens */
        @media (max-width: 767.98px) {
            .mode-side-by-side .view-mode-container {
                display: block;
                height: auto;
            }
            .mode-side-by-side .editor-container,
            .mode-side-by-side .preview-container {
                width: 100% !important;
                flex: none;
                overflow: visible;
                height: auto;
            }
            .mode-side-by-side #markdownInput {
                height: auto !important;
                resize: vertical;
            }
            .mode-side-by-side #markdownPreview {
                overflow-y: visible;
            }
            .mode-side-by-side .resize-divider {
                display: none;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">View Scrubbai</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse justify-content-end" id="navbarNav">
                <div class="dropdown">
                    <button class="btn btn-outline-light dropdown-toggle" type="button" id="settingsDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gear me-1" viewBox="0 0 16 16">
                            <path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492M5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0"/>
                            <path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.902 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.159a.873.873 0 0 1-1.255-.52zm-2.633.283c.246-.835 1.428-.835 1.674 0l.094.319a1.873 1.873 0 0 0 2.693 1.115l.291-.16c.764-.415 1.6.42 1.184 1.185l-.159.292a1.873 1.873 0 0 0 1.116 2.692l.318.094c.835.246.835 1.428 0 1.674l-.319.094a1.873 1.873 0 0 0-1.115 2.693l.16.291c.415.764-.42 1.6-1.185 1.184l-.291-.159a1.873 1.873 0 0 0-2.693 1.116l-.094.318c-.246.835-1.428.835-1.674 0l-.094-.319a1.873 1.873 0 0 0-2.692-1.115l-.292.16c-.764.415-1.6-.42-1.184-1.185l.159-.291A1.873 1.873 0 0 0 1.945 8.93l-.319-.094c-.835-.246-.835-1.428 0-1.674l.319-.094A1.873 1.873 0 0 0 3.06 4.377l-.16-.292c-.415-.764.42-1.6 1.185-1.184l.292.159a1.873 1.873 0 0 0 2.692-1.115z"/>
                        </svg>
                        Settings
                    </button>
                    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="settingsDropdown">
                        <li class="dropdown-item-text">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="layoutToggle">
                                <label class="form-check-label" for="layoutToggle">Side-by-Side</label>
                            </div>
                        </li>
                        <li class="dropdown-item-text">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="swapSidesToggle">
                                <label class="form-check-label" for="swapSidesToggle">Swap Sides</label>
                            </div>
                        </li>
                        <li class="dropdown-item-text">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="highlightIssuesToggle">
                                <label class="form-check-label" for="highlightIssuesToggle">Highlight Issues</label>
                            </div>
                        </li>
                        <li><hr class="dropdown-divider"></li>
                        <li class="dropdown-item-text">
                            <div class="d-flex align-items-center gap-2">
                                <span class="theme-icon">&#9728;</span>
                                <div class="form-check form-switch mb-0">
                                    <input class="form-check-input" type="checkbox" id="themeToggle">
                                </div>
                                <span class="theme-icon">&#9790;</span>
                                <span class="ms-1">Theme</span>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </nav>

    <div id="mainContainer" class="container-fluid">
        <div class="view-mode-container">
            <div class="editor-container card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <nav aria-label="breadcrumb">
                            <ol class="breadcrumb mb-0">
                                <li class="breadcrumb-item active">Markdown Editor</li>
                            </ol>
                        </nav>
                        <span id="statusIndicator" class="badge bg-success">Valid</span>
                    </div>
                    <div class="textarea-wrapper mb-2">
                        <textarea
                            id="markdownInput"
                            class="form-control"
                            rows="20"
                            placeholder="Type or paste your markdown here...&#10;&#10;# Example Heading&#10;&#10;This is a **bold** statement with *italic* text.&#10;&#10;- List item 1&#10;- List item 2&#10;&#10;```javascript&#10;console.log('Hello, World!');&#10;```&#10;&#10;```mermaid&#10;graph TD;&#10;    A-->B;&#10;```"
                        ></textarea>
                    </div>
                    <div class="button-group">
                        <button id="clearBtn" class="btn btn-outline-secondary btn-sm">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-trash me-1" viewBox="0 0 16 16">
                                <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                                <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/>
                            </svg>
                            Clear
                        </button>
                        <button id="rerenderBtn" class="btn btn-primary btn-sm">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-arrow-clockwise me-1" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
                                <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
                            </svg>
                            Re-render
                        </button>
                    </div>
                </div>
            </div>

            <div class="resize-divider bg-secondary" id="resizeDivider"></div>

            <div class="preview-container card">
                <div class="card-body">
                    <nav aria-label="breadcrumb" class="mb-2">
                        <ol class="breadcrumb mb-0">
                            <li class="breadcrumb-item active">Preview</li>
                        </ol>
                    </nav>
                    <div id="markdownPreview" class="empty-state">
                        Your rendered markdown will appear here...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-muted small py-3">
        <div class="container-fluid">
            <p class="mb-0">&copy; 2024 View Scrubbai. Built with markdown-it and Bootstrap 5.</p>
        </div>
    </footer>

    <!-- Bootstrap 5 JS Bundle (optional for this use case, but included for completeness) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

    <script>
        // =====================================================
        // MARKDOWN-IT CONFIGURATION WITH SOURCE LINE INJECTION
        // =====================================================

        // Initialize markdown-it with GFM-like options
        const md = window.markdownit({
            html: true,
            breaks: true,
            linkify: true,
            typographer: false
        });

        // Store the default fence renderer
        const defaultFenceRenderer = md.renderer.rules.fence || function(tokens, idx, options, env, self) {
            return self.renderToken(tokens, idx, options);
        };

        // Default Mermaid width
        const DEFAULT_MERMAID_WIDTH = 600;

        // Custom fence renderer for Mermaid support with resizable container
        md.renderer.rules.fence = function(tokens, idx, options, env, self) {
            const token = tokens[idx];
            const info = token.info ? token.info.trim() : '';
            const parts = info.split(/\s+/g);
            const lang = parts[0];

            if (lang === 'mermaid') {
                const line = token.map ? token.map[0] : 0;

                // Parse optional width from info string: ```mermaid width=500
                let width = DEFAULT_MERMAID_WIDTH;
                for (let i = 1; i < parts.length; i++) {
                    const match = parts[i].match(/^width=(\d+)$/);
                    if (match) {
                        width = parseInt(match[1], 10);
                    }
                }

                // Wrap in resizable container
                return `<div class="mermaid-container" data-source-line="${line}" style="width: ${width}px;">
                    <span class="mermaid-width-indicator">${width}px</span>
                    <div class="mermaid">${md.utils.escapeHtml(token.content)}</div>
                    <div class="mermaid-resize-handle" title="Drag to resize"></div>
                </div>`;
            }

            // For other code blocks, add source line and use default rendering
            const line = token.map ? token.map[0] : 0;
            const langClass = lang ? ` class="language-${lang}"` : '';
            const escaped = md.utils.escapeHtml(token.content);
            return `<pre data-source-line="${line}"><code${langClass}>${escaped}</code></pre>`;
        };

        // Inject source line numbers into block-level elements (VS Code approach)
        // This adds data-source-line attributes to rendered HTML for scroll sync
        md.core.ruler.push('source_line_injector', function(state) {
            for (let i = 0; i < state.tokens.length; i++) {
                const token = state.tokens[i];
                // Add line info to block tokens that have map info
                if (token.map && token.nesting >= 0) {
                    token.attrSet('data-source-line', String(token.map[0]));
                    token.attrJoin('class', 'source-line');
                }
            }
        });

        // Initialize Mermaid with sensible defaults
        mermaid.initialize({
            startOnLoad: false,
            flowchart: { useMaxWidth: true, htmlLabels: true },
            sequence: { useMaxWidth: true },
            gantt: { useMaxWidth: true },
            journey: { useMaxWidth: true },
            class: { useMaxWidth: true },
            state: { useMaxWidth: true },
            er: { useMaxWidth: true },
            pie: { useMaxWidth: true }
        });

        // =====================================================
        // DOM ELEMENTS
        // =====================================================

        const markdownInput = document.getElementById('markdownInput');
        const markdownPreview = document.getElementById('markdownPreview');
        const statusIndicator = document.getElementById('statusIndicator');
        const clearBtn = document.getElementById('clearBtn');
        const rerenderBtn = document.getElementById('rerenderBtn');

        const layoutToggle = document.getElementById('layoutToggle');
        const mainContainer = document.getElementById('mainContainer');
        const themeToggle = document.getElementById('themeToggle');
        const themeStylesheet = document.getElementById('theme-stylesheet');
        const resizeDivider = document.getElementById('resizeDivider');
        const editorContainer = document.querySelector('.editor-container');
        const previewContainer = document.querySelector('.preview-container');

        // Theme URLs
        const THEME_LIGHT = 'https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/flatly/bootstrap.min.css';
        const THEME_DARK = 'https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/darkly/bootstrap.min.css';

        // Debounce timer
        let debounceTimer;

        // =====================================================
        // SCROLL SYNC WITH SOURCE LINE MAPPING & INTERPOLATION
        // (Based on Joplin's SyncScrollMap approach)
        // =====================================================

        /**
         * SyncScrollMap - Manages mapping between editor lines and preview positions
         * Uses percentage-based positions for GUI-independence
         * Implements binary search for efficient lookups
         */
        class SyncScrollMap {
            constructor() {
                this.map = null; // Array of {line, percent} sorted by line
                this.valid = false;
            }

            /**
             * Build the mapping from source lines to preview scroll percentages
             */
            build() {
                const elements = markdownPreview.querySelectorAll('[data-source-line]');
                const previewScrollHeight = markdownPreview.scrollHeight - markdownPreview.clientHeight;

                if (previewScrollHeight <= 0 || elements.length === 0) {
                    this.map = [];
                    this.valid = true;
                    return;
                }

                const entries = [];
                const previewRect = markdownPreview.getBoundingClientRect();

                elements.forEach(el => {
                    const line = parseInt(el.getAttribute('data-source-line'), 10);
                    if (isNaN(line)) return;

                    const rect = el.getBoundingClientRect();
                    // Position relative to preview container
                    const top = rect.top - previewRect.top + markdownPreview.scrollTop;
                    // Convert to percentage (0 to 1)
                    const percent = Math.max(0, Math.min(1, top / previewScrollHeight));

                    entries.push({ line, percent });
                });

                // Sort by line number and remove duplicates (keep first occurrence)
                entries.sort((a, b) => a.line - b.line);
                this.map = [];
                let lastLine = -1;
                for (const entry of entries) {
                    if (entry.line !== lastLine) {
                        this.map.push(entry);
                        lastLine = entry.line;
                    }
                }

                this.valid = true;
            }

            /**
             * Invalidate the map (will be rebuilt on next use)
             */
            invalidate() {
                this.valid = false;
                this.map = null;
            }

            /**
             * Binary search to find the rightmost index where map[i].line <= targetLine
             * Returns -1 if all lines are greater than target
             */
            binarySearchByLine(targetLine) {
                if (!this.map || this.map.length === 0) return -1;

                let left = 0;
                let right = this.map.length - 1;
                let result = -1;

                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    if (this.map[mid].line <= targetLine) {
                        result = mid;
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }

                return result;
            }

            /**
             * Binary search to find the rightmost index where map[i].percent <= targetPercent
             */
            binarySearchByPercent(targetPercent) {
                if (!this.map || this.map.length === 0) return -1;

                let left = 0;
                let right = this.map.length - 1;
                let result = -1;

                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    if (this.map[mid].percent <= targetPercent) {
                        result = mid;
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }

                return result;
            }

            /**
             * Translate editor line to preview scroll percentage using linear interpolation
             */
            lineToPreviewPercent(line) {
                if (!this.valid) this.build();
                if (!this.map || this.map.length === 0) return null;

                // Edge cases
                if (line <= this.map[0].line) return this.map[0].percent;
                if (line >= this.map[this.map.length - 1].line) return this.map[this.map.length - 1].percent;

                // Binary search for the bracket
                const lowerIdx = this.binarySearchByLine(line);
                if (lowerIdx < 0) return this.map[0].percent;

                const upperIdx = lowerIdx + 1;
                if (upperIdx >= this.map.length) return this.map[lowerIdx].percent;

                const lower = this.map[lowerIdx];
                const upper = this.map[upperIdx];

                // Exact match
                if (lower.line === line) return lower.percent;

                // Linear interpolation
                const lineRange = upper.line - lower.line;
                if (lineRange === 0) return lower.percent;

                const ratio = (line - lower.line) / lineRange;
                return lower.percent + ratio * (upper.percent - lower.percent);
            }

            /**
             * Translate preview scroll percentage to editor line using linear interpolation
             */
            previewPercentToLine(percent) {
                if (!this.valid) this.build();
                if (!this.map || this.map.length === 0) return null;

                // Clamp percent
                percent = Math.max(0, Math.min(1, percent));

                // Edge cases
                if (percent <= this.map[0].percent) return this.map[0].line;
                if (percent >= this.map[this.map.length - 1].percent) return this.map[this.map.length - 1].line;

                // Binary search for the bracket
                const lowerIdx = this.binarySearchByPercent(percent);
                if (lowerIdx < 0) return this.map[0].line;

                const upperIdx = lowerIdx + 1;
                if (upperIdx >= this.map.length) return this.map[lowerIdx].line;

                const lower = this.map[lowerIdx];
                const upper = this.map[upperIdx];

                // Exact match
                if (lower.percent === percent) return lower.line;

                // Linear interpolation
                const percentRange = upper.percent - lower.percent;
                if (percentRange === 0) return lower.line;

                const ratio = (percent - lower.percent) / percentRange;
                return lower.line + ratio * (upper.line - lower.line);
            }
        }

        // Scroll sync state
        const syncScrollMap = new SyncScrollMap();
        let ignoreNextEditorScroll = false;
        let ignoreNextPreviewScroll = false;
        let editorScrollTimeoutId = null;
        let previewScrollTimeoutId = null;
        let resizeObserver = null;

        // Debounce delay for scroll events (ms)
        const SCROLL_SYNC_DEBOUNCE = 10;

        /**
         * Get editor scroll position as percentage (0 to 1)
         */
        function getEditorScrollPercent() {
            const scrollHeight = markdownInput.scrollHeight - markdownInput.clientHeight;
            if (scrollHeight <= 0) return 0;
            return markdownInput.scrollTop / scrollHeight;
        }

        /**
         * Set editor scroll position from percentage
         */
        function setEditorScrollPercent(percent) {
            const scrollHeight = markdownInput.scrollHeight - markdownInput.clientHeight;
            markdownInput.scrollTop = percent * scrollHeight;
        }

        /**
         * Get preview scroll position as percentage (0 to 1)
         */
        function getPreviewScrollPercent() {
            const scrollHeight = markdownPreview.scrollHeight - markdownPreview.clientHeight;
            if (scrollHeight <= 0) return 0;
            return markdownPreview.scrollTop / scrollHeight;
        }

        /**
         * Set preview scroll position from percentage
         */
        function setPreviewScrollPercent(percent) {
            const scrollHeight = markdownPreview.scrollHeight - markdownPreview.clientHeight;
            markdownPreview.scrollTop = percent * scrollHeight;
        }

        /**
         * Get editor line height (approximate)
         */
        function getEditorLineHeight() {
            const style = window.getComputedStyle(markdownInput);
            const lineHeight = parseFloat(style.lineHeight);
            if (!isNaN(lineHeight) && lineHeight > 0) return lineHeight;
            const fontSize = parseFloat(style.fontSize) || 14;
            return fontSize * 1.4;
        }

        /**
         * Convert editor scroll percent to approximate line number
         */
        function editorPercentToLine(percent) {
            const lineHeight = getEditorLineHeight();
            const scrollHeight = markdownInput.scrollHeight - markdownInput.clientHeight;
            if (scrollHeight <= 0) return 0;
            const scrollTop = percent * scrollHeight;
            return scrollTop / lineHeight;
        }

        /**
         * Convert editor line to scroll percent
         */
        function editorLineToPercent(line) {
            const lineHeight = getEditorLineHeight();
            const scrollHeight = markdownInput.scrollHeight - markdownInput.clientHeight;
            if (scrollHeight <= 0) return 0;
            return (line * lineHeight) / scrollHeight;
        }

        /**
         * Sync preview scroll when editor scrolls
         */
        function syncEditorToPreview() {
            if (!layoutToggle.checked) return;

            // Check if we should ignore this event (caused by programmatic scroll)
            if (ignoreNextEditorScroll) {
                ignoreNextEditorScroll = false;
                return;
            }

            // Debounce
            if (editorScrollTimeoutId) {
                clearTimeout(editorScrollTimeoutId);
            }

            editorScrollTimeoutId = setTimeout(() => {
                editorScrollTimeoutId = null;

                // Get current editor line from scroll percent
                const editorPercent = getEditorScrollPercent();
                const currentLine = editorPercentToLine(editorPercent);

                // Translate to preview percent
                const previewPercent = syncScrollMap.lineToPreviewPercent(currentLine);
                if (previewPercent === null) return;

                // Set flag to ignore the resulting scroll event
                ignoreNextPreviewScroll = true;

                // Apply scroll
                setPreviewScrollPercent(previewPercent);

                // Reset ignore flag after scroll event has fired
                setTimeout(() => { ignoreNextPreviewScroll = false; }, 50);
            }, SCROLL_SYNC_DEBOUNCE);
        }

        /**
         * Sync editor scroll when preview scrolls
         */
        function syncPreviewToEditor() {
            if (!layoutToggle.checked) return;

            // Check if we should ignore this event
            if (ignoreNextPreviewScroll) {
                ignoreNextPreviewScroll = false;
                return;
            }

            // Debounce
            if (previewScrollTimeoutId) {
                clearTimeout(previewScrollTimeoutId);
            }

            previewScrollTimeoutId = setTimeout(() => {
                previewScrollTimeoutId = null;

                // Get current preview scroll percent
                const previewPercent = getPreviewScrollPercent();

                // Translate to editor line, then to editor percent
                const targetLine = syncScrollMap.previewPercentToLine(previewPercent);
                if (targetLine === null) return;

                const editorPercent = editorLineToPercent(targetLine);

                // Set flag to ignore the resulting scroll event
                ignoreNextEditorScroll = true;

                // Apply scroll
                setEditorScrollPercent(editorPercent);

                // Reset ignore flag after scroll event has fired
                setTimeout(() => { ignoreNextEditorScroll = false; }, 50);
            }, SCROLL_SYNC_DEBOUNCE);
        }

        /**
         * Initialize scroll sync with ResizeObserver for automatic map invalidation
         */
        function initScrollSync() {
            // Build initial map
            syncScrollMap.build();

            // Set up ResizeObserver to detect when preview content changes size
            if (window.ResizeObserver) {
                resizeObserver = new ResizeObserver(() => {
                    // Invalidate map when size changes (images loaded, etc.)
                    syncScrollMap.invalidate();
                });
                resizeObserver.observe(markdownPreview);
            }

            // Add scroll listeners
            markdownInput.addEventListener('scroll', syncEditorToPreview);
            markdownPreview.addEventListener('scroll', syncPreviewToEditor);
        }

        /**
         * Remove scroll sync and clean up
         */
        function removeScrollSync() {
            markdownInput.removeEventListener('scroll', syncEditorToPreview);
            markdownPreview.removeEventListener('scroll', syncPreviewToEditor);

            if (resizeObserver) {
                resizeObserver.disconnect();
                resizeObserver = null;
            }

            // Clear any pending timeouts
            if (editorScrollTimeoutId) clearTimeout(editorScrollTimeoutId);
            if (previewScrollTimeoutId) clearTimeout(previewScrollTimeoutId);
            editorScrollTimeoutId = null;
            previewScrollTimeoutId = null;

            // Reset flags
            ignoreNextEditorScroll = false;
            ignoreNextPreviewScroll = false;

            syncScrollMap.invalidate();
        }

        /**
         * Invalidate scroll sync map (call after rendering)
         */
        function invalidateScrollSyncMap() {
            syncScrollMap.invalidate();
        }

        // =====================================================
        // THEME HANDLING
        // =====================================================

        function setTheme(isDark) {
            const mermaidConfig = {
                startOnLoad: false,
                theme: isDark ? 'dark' : 'default',
                flowchart: { useMaxWidth: true, htmlLabels: true },
                sequence: { useMaxWidth: true },
                gantt: { useMaxWidth: true },
                journey: { useMaxWidth: true },
                class: { useMaxWidth: true },
                state: { useMaxWidth: true },
                er: { useMaxWidth: true },
                pie: { useMaxWidth: true }
            };

            if (isDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeStylesheet.href = THEME_DARK;
            } else {
                document.documentElement.removeAttribute('data-theme');
                themeStylesheet.href = THEME_LIGHT;
            }

            mermaid.initialize(mermaidConfig);
            renderMarkdown();
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }

        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                themeToggle.checked = true;
                setTheme(true);
            }
        }

        // =====================================================
        // LAYOUT TOGGLE
        // =====================================================

        function toggleLayout() {
            const isSideBySide = layoutToggle.checked;

            if (isSideBySide) {
                document.body.classList.add('mode-side-by-side');
                editorContainer.style.flex = '0 0 50%';
                initScrollSync();
            } else {
                document.body.classList.remove('mode-side-by-side');
                editorContainer.style.flex = '';
                removeScrollSync();
            }
        }

        /**
         * Toggle swapped sides (editor on right, preview on left)
         */
        function toggleSwapSides() {
            const swapSidesToggle = document.getElementById('swapSidesToggle');
            const isSwapped = swapSidesToggle.checked;

            if (isSwapped) {
                document.body.classList.add('mode-swapped');
            } else {
                document.body.classList.remove('mode-swapped');
            }

            // Save preference
            localStorage.setItem('swapSides', isSwapped ? 'true' : 'false');
        }

        /**
         * Load saved swap sides preference
         */
        function loadSwapSidesPreference() {
            const swapSidesToggle = document.getElementById('swapSidesToggle');
            const savedPref = localStorage.getItem('swapSides');
            if (savedPref === 'true') {
                swapSidesToggle.checked = true;
                document.body.classList.add('mode-swapped');
            }
        }

        // =====================================================
        // RESIZABLE DIVIDER
        // =====================================================

        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        function startResize(e) {
            if (!layoutToggle.checked) return;
            isResizing = true;
            startX = e.clientX || e.touches[0].clientX;
            startWidth = editorContainer.offsetWidth;
            document.body.classList.add('resizing');
            resizeDivider.classList.add('dragging');

            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
            document.addEventListener('touchmove', doResize);
            document.addEventListener('touchend', stopResize);
        }

        function doResize(e) {
            if (!isResizing) return;
            e.preventDefault();

            const clientX = e.clientX || e.touches[0].clientX;
            const container = document.querySelector('.view-mode-container');
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width;

            const newWidth = startWidth + (clientX - startX);
            const minWidth = containerWidth * 0.2;
            const maxWidth = containerWidth * 0.8;

            const clampedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
            const percentage = (clampedWidth / containerWidth) * 100;

            editorContainer.style.flex = `0 0 ${percentage}%`;
        }

        function stopResize() {
            isResizing = false;
            document.body.classList.remove('resizing');
            resizeDivider.classList.remove('dragging');

            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
            document.removeEventListener('touchmove', doResize);
            document.removeEventListener('touchend', stopResize);

            // Rebuild scroll sync map after resize
            if (layoutToggle.checked) {
                syncScrollMap.invalidate();
                syncScrollMap.build();
            }
        }

        // =====================================================
        // MERMAID DIAGRAM RESIZING
        // =====================================================

        let mermaidResizing = false;
        let mermaidResizeTarget = null;
        let mermaidStartX = 0;
        let mermaidStartWidth = 0;

        /**
         * Initialize Mermaid resize handles after rendering
         * Uses event delegation on the preview container
         */
        function initMermaidResizeHandlers() {
            // Use event delegation - listen on preview container
            markdownPreview.addEventListener('mousedown', handleMermaidResizeStart);
            markdownPreview.addEventListener('touchstart', handleMermaidResizeStart);
        }

        function handleMermaidResizeStart(e) {
            const handle = e.target.closest('.mermaid-resize-handle');
            if (!handle) return;

            e.preventDefault();
            mermaidResizing = true;
            mermaidResizeTarget = handle.closest('.mermaid-container');
            mermaidStartX = e.clientX || e.touches[0].clientX;
            mermaidStartWidth = mermaidResizeTarget.offsetWidth;

            document.body.classList.add('resizing-mermaid');
            handle.classList.add('dragging');

            document.addEventListener('mousemove', handleMermaidResize);
            document.addEventListener('mouseup', handleMermaidResizeEnd);
            document.addEventListener('touchmove', handleMermaidResize);
            document.addEventListener('touchend', handleMermaidResizeEnd);
        }

        function handleMermaidResize(e) {
            if (!mermaidResizing || !mermaidResizeTarget) return;
            e.preventDefault();

            const clientX = e.clientX || e.touches[0].clientX;
            const delta = clientX - mermaidStartX;
            const newWidth = Math.max(200, Math.min(1200, mermaidStartWidth + delta));

            mermaidResizeTarget.style.width = `${newWidth}px`;

            // Update the width indicator
            const indicator = mermaidResizeTarget.querySelector('.mermaid-width-indicator');
            if (indicator) {
                indicator.textContent = `${Math.round(newWidth)}px`;
            }
        }

        function handleMermaidResizeEnd() {
            if (!mermaidResizing) return;

            const handle = mermaidResizeTarget?.querySelector('.mermaid-resize-handle');
            if (handle) {
                handle.classList.remove('dragging');
            }

            mermaidResizing = false;
            mermaidResizeTarget = null;
            document.body.classList.remove('resizing-mermaid');

            document.removeEventListener('mousemove', handleMermaidResize);
            document.removeEventListener('mouseup', handleMermaidResizeEnd);
            document.removeEventListener('touchmove', handleMermaidResize);
            document.removeEventListener('touchend', handleMermaidResizeEnd);

            // Rebuild scroll sync map after mermaid resize
            if (layoutToggle.checked) {
                syncScrollMap.invalidate();
                syncScrollMap.build();
            }
        }

        // =====================================================
        // MARKDOWN LINTING
        // =====================================================

        function lintMarkdown(content) {
            if (!content.trim()) {
                return { status: 'valid', message: 'Valid markdown - No issues detected' };
            }

            const issues = [];
            const lines = content.split('\n');

            // Check for mismatched header levels
            const headerMatches = content.match(/^#{1,6}\s/gm);
            if (headerMatches) {
                const headerLevels = headerMatches.map(h => h.trim().split(' ')[0].length);
                for (let i = 1; i < headerLevels.length; i++) {
                    if (headerLevels[i] - headerLevels[i - 1] > 1) {
                        issues.push('Skipped header level detected');
                        break;
                    }
                }
            }

            // Check for unclosed code blocks
            const codeBlockMatches = content.match(/```/g);
            if (codeBlockMatches && codeBlockMatches.length % 2 !== 0) {
                return { status: 'error', message: 'Syntax error - Unclosed code block detected' };
            }

            // Check for unclosed inline code
            const inlineCodeMatches = content.match(/`/g);
            if (inlineCodeMatches) {
                let count = 0;
                for (let line of lines) {
                    if (line.trim().startsWith('```')) continue;
                    const backticks = (line.match(/`/g) || []).length;
                    count += backticks;
                }
                if (!codeBlockMatches && count % 2 !== 0) {
                    return { status: 'error', message: 'Syntax error - Unclosed inline code detected' };
                }
            }

            // Check for malformed links
            const malformedLinks = content.match(/\[[^\]]*\]\([^)]*$/gm);
            if (malformedLinks) {
                return { status: 'error', message: 'Syntax error - Malformed link detected' };
            }

            // Check for inconsistent list formatting
            const listItems = content.match(/^\s*[-*+]\s/gm);
            if (listItems) {
                const markers = listItems.map(item => item.trim()[0]);
                const uniqueMarkers = [...new Set(markers)];
                if (uniqueMarkers.length > 1) {
                    issues.push('Inconsistent list markers');
                }
            }

            // Check for multiple consecutive blank lines
            if (content.match(/\n\s*\n\s*\n/)) {
                issues.push('Multiple consecutive blank lines');
            }

            // Check for trailing spaces
            const trailingSpaces = lines.filter(line => line.match(/\s+$/));
            if (trailingSpaces.length > 2) {
                issues.push('Excessive trailing spaces');
            }

            if (issues.length === 0) {
                return { status: 'valid', message: 'Valid markdown - No issues detected' };
            } else {
                return { status: 'warning', message: `Minor formatting issues - ${issues.join(', ')}` };
            }
        }

        function updateStatus(lintResult) {
            // Update badge
            statusIndicator.className = 'badge';

            switch (lintResult.status) {
                case 'valid':
                    statusIndicator.classList.add('bg-success');
                    statusIndicator.textContent = 'Valid';
                    statusIndicator.title = lintResult.message;
                    break;
                case 'warning':
                    statusIndicator.classList.add('bg-warning', 'text-dark');
                    statusIndicator.textContent = 'Warning';
                    statusIndicator.title = lintResult.message;
                    break;
                case 'error':
                    statusIndicator.classList.add('bg-danger');
                    statusIndicator.textContent = 'Error';
                    statusIndicator.title = lintResult.message;
                    break;
            }

            // Handle highlight issues setting
            const highlightToggle = document.getElementById('highlightIssuesToggle');
            if (highlightToggle && highlightToggle.checked) {
                if (lintResult.status === 'error') {
                    document.body.classList.add('highlight-issues');
                    document.body.classList.remove('has-warning');
                } else if (lintResult.status === 'warning') {
                    document.body.classList.add('highlight-issues', 'has-warning');
                } else {
                    document.body.classList.remove('highlight-issues', 'has-warning');
                }
            } else {
                document.body.classList.remove('highlight-issues', 'has-warning');
            }
        }

        // =====================================================
        // RENDER MARKDOWN
        // =====================================================

        function renderMarkdown() {
            const content = markdownInput.value;

            // Lint the markdown
            const lintResult = lintMarkdown(content);
            updateStatus(lintResult);

            // Render empty state
            if (!content.trim()) {
                markdownPreview.innerHTML = '<div class="empty-state">Your rendered markdown will appear here...</div>';
                invalidateScrollSyncMap();
                return;
            }

            try {
                // Render using markdown-it
                const html = md.render(content);
                markdownPreview.innerHTML = html;

                // Initialize Mermaid diagrams
                mermaid.run({
                    nodes: document.querySelectorAll('.mermaid')
                });

                // Invalidate and rebuild scroll sync map after render
                syncScrollMap.invalidate();
                if (layoutToggle.checked) {
                    // Delay slightly to allow DOM to settle
                    setTimeout(() => {
                        syncScrollMap.build();
                    }, 100);
                }
            } catch (error) {
                markdownPreview.innerHTML = `<div class="alert alert-danger">
                    <strong>Rendering Error:</strong> ${error.message}
                </div>`;
                updateStatus({ status: 'error', message: 'Syntax error - Failed to render markdown' });
            }
        }

        function debouncedRender() {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(renderMarkdown, 300);
        }

        function clearEditor() {
            markdownInput.value = '';
            renderMarkdown();
            markdownInput.focus();
        }

        // =====================================================
        // EVENT LISTENERS
        // =====================================================

        markdownInput.addEventListener('input', debouncedRender);
        clearBtn.addEventListener('click', clearEditor);
        rerenderBtn.addEventListener('click', renderMarkdown);

        layoutToggle.addEventListener('change', toggleLayout);
        themeToggle.addEventListener('change', () => setTheme(themeToggle.checked));
        document.getElementById('swapSidesToggle').addEventListener('change', toggleSwapSides);
        document.getElementById('highlightIssuesToggle').addEventListener('change', () => {
            // Re-run linting to update highlight state
            const lintResult = lintMarkdown(markdownInput.value);
            updateStatus(lintResult);
            // Save preference
            localStorage.setItem('highlightIssues', document.getElementById('highlightIssuesToggle').checked ? 'true' : 'false');
        });

        resizeDivider.addEventListener('mousedown', startResize);
        resizeDivider.addEventListener('touchstart', startResize);

        // Initialize Mermaid resize handlers (event delegation)
        initMermaidResizeHandlers();

        // Load saved preferences
        loadSavedTheme();
        loadSwapSidesPreference();

        // Load highlight issues preference
        if (localStorage.getItem('highlightIssues') === 'true') {
            document.getElementById('highlightIssuesToggle').checked = true;
        }

        // Initial render
        renderMarkdown();

        // Fallback check for markdown-it
        if (typeof window.markdownit === 'undefined') {
            markdownPreview.innerHTML = `
                <div class="alert alert-danger">
                    <strong>Error:</strong> Failed to load markdown-it library. Please check your internet connection.
                </div>
            `;
        }
    </script>
</body>
</html>
